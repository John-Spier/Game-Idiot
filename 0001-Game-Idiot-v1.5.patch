From a2946c74b833ebd29c56369d7bdce7bc5341c7c7 Mon Sep 17 00:00:00 2001
From: John-Spier <102952652+John-Spier@users.noreply.github.com>
Date: Fri, 2 Jan 2026 10:41:17 -0500
Subject: [PATCH] Game Idiot v1.5

---
 CONTROL.C  |  659 ++++++++++++++++-
 CONTROL.H  |   35 +-
 HITMOD.H   |   46 ++
 HITMOD.OBJ |  Bin 0 -> 15830 bytes
 MAIN.C     | 1950 ++++++++++++++++++++++++++++++++++++------------
 MAIN.H     |   40 +-
 MAIN.LNK   |   10 +-
 MOVIE.C    |  439 +++++++----
 MOVIE.H    |   15 +-
 SCEECD.C   |  516 ++++++-------
 SCEECD.H   |   29 +-
 TIMVIEW.C  |   90 ++-
 TIMVIEW.H  |    3 +-
 debugcd.c  |  300 ++++++++
 debugcd.h  |   17 +
 make.bat   |   13 +
 music.c    | 2098 ++++++++++++++++++++++++++++++++++++++++++++++++++++
 music.h    |  254 +++++++
 18 files changed, 5512 insertions(+), 1002 deletions(-)
 create mode 100644 HITMOD.H
 create mode 100644 HITMOD.OBJ
 create mode 100644 debugcd.c
 create mode 100644 debugcd.h
 create mode 100644 make.bat
 create mode 100644 music.c
 create mode 100644 music.h

diff --git a/CONTROL.C b/CONTROL.C
index bc0da47..45f469e 100644
--- a/CONTROL.C
+++ b/CONTROL.C
@@ -22,8 +22,19 @@
 #include <libgpu.h>
 #include <libetc.h>
 
+#include <libcd.h>
+#include <libspu.h>
+#include <libsnd.h>
+#include <xmplay.h>
+
+#include "hitmod.h"
+
 #include "ctrller.h"
+//#include "state.h"
 #include "control.h"
+#include "sceecd.h"
+
+#include "music.h"
 
 /* ---------------------------------------------------------------------------
  * - CONSTANTS 
@@ -40,16 +51,405 @@
 #define PAD_TWO			2
 #define BOTH_PADS		3
 
+//#define INPUT_DELAY			20
+//#define INPUT_DELAY_REPEAT			1 //frames between repeats
+#define REPEAT_DELAY			1 //number of inputs before repeats
+
+//#define VIEWOSD			10
+#define VIEWFILES			10
+
 /* ---------------------------------------------------------------------------
  * - GLOBAL DEFINITIONS 
  * ---------------------------------------------------------------------------
  */
-
 static volatile short connected = 0;			// No. controllers connected.
 static volatile short currController = 0;		// Current active controller.
 
 static volatile ControllerPacket buffers[2];
 
+short block = 20;
+u_short lastPressed = 0;
+u_short hPressed = 0;
+short repeats = REPEAT_DELAY;
+
+int prev_vsync = 0;
+
+extern ParamsShared p;
+extern short seq1;
+extern int seqLength;
+extern short seqVoices;
+extern int StreamPlaying;
+//extern u_long* songData;
+
+extern XM_Feedback Feedback;
+extern XM_Feedback *FB;
+
+/*
+char* table1[] = 
+{
+	"Table 1 - ONE",
+	"Table 1 - TWO"
+};
+
+char* table2[] = 
+{
+	"Table 2 - ONE",
+	"Table 2 - TWO"
+};
+*/
+
+char* TABLE_CHANNELS[] =
+{
+	"Stereo",
+	"Mono",
+	"Left only",
+	"Right only",
+	"Reverse stereo"
+};
+
+char* TABLE_PANREGION[] =
+{
+	"XM NTSC",
+	"S3M NTSC",
+	"XM PAL",
+	"S3M PAL"
+};
+
+char* TABLE_TICKMODE[] =
+{
+	"Manual",
+	"60 Per Second",
+	"240 Per Second",
+	"120 Per Second",
+	"50 Per Second",
+	"Once per VSync",
+	"Maximum"
+};
+
+char* TABLE_LOOPS[] =
+{
+	"Infinite"
+};
+
+char* TABLE_FRAMES[] =
+{
+	"1 frame"
+};
+
+char* TABLE_ONOFF[] =
+{
+	"Off",
+	"On"
+};
+char* TABLE_BITDEPTH[] =
+{
+	"16 bit",
+	"24 bit"
+};
+char* TABLE_REVMODE[] =
+{
+	"None",
+	"Room",
+	"Studio (small)",
+	"Studio (medium)",
+	"Studio (large)",
+	"Hall",
+	"Space echo",
+	"Echo",
+	"Delay",
+	"Pipe echo"
+};
+char* TABLE_FORCE[] =
+{
+	"Don't load parameters",
+	"Normal",
+	"Reset volume",
+	"For SEQ",
+	"For all audio",
+	"Always"
+};
+//const int OSDTYPES = 16;
+
+OSDITEM OSDItems[] = 
+{
+	/*
+	{
+		"String 1 %s\n", //Name with string table
+		"Int 1 %d\n", //Name with integer
+		0, //Type of value
+		0, //Minimum value to use strings
+		1, //Maximum value to use strings
+		table1 //String table
+	},
+	*/
+	{
+		"Volume          %s/127\n", //Name with string table
+		"Volume          %d\n", //Name with integer
+		OSD_VOLUME, //Type of value
+		1, //Minimum value to use strings
+		-1, //Maximum value to use strings
+		0 //String table
+	},
+	{
+		"Master Volume   %s/127\n", //Name with string table
+		"Master Volume   %d\n", //Name with integer
+		OSD_MVOLUME, //Type of value
+		1, //Minimum value to use strings
+		-1, //Maximum value to use strings
+		0 //String table
+	},
+	{
+		"Channels        %s\n", //Name with string table
+		"Channels        %d\n", //Name with integer
+		OSD_CHANNELS, //Type of value
+		0, //Minimum value to use strings
+		4, //Maximum value to use strings
+		TABLE_CHANNELS //String table
+	},
+	{
+		"XM Settings     %s\n", //Name with string table
+		"xm %d\n", //Name with integer
+		OSD_PANREGION, //Type of value
+		0, //Minimum value to use strings
+		3, //Maximum value to use strings
+		TABLE_PANREGION //String table
+	},
+	{
+		"Tick mode       %s\n", //Name with string table
+		"Tick mode       %d/second\n", //Name with integer
+		OSD_TICKMODE, //Type of value
+		0, //Minimum value to use strings
+		6, //Maximum value to use strings
+		TABLE_TICKMODE //String table
+	},
+	{
+		"Sequence Loops  %s\n", //Name with string table
+		"Sequence loops  %d\n", //Name with integer
+		OSD_LOOPS, //Type of value
+		0, //Minimum value to use strings
+		0, //Maximum value to use strings
+		TABLE_LOOPS //String table
+	},
+	{
+		"\n", //Name with string table
+		"\n", //Name with integer
+		OSD_NONE, //Type of value
+		1, //Minimum value to use strings
+		-1, //Maximum value to use strings
+		0 //String table
+	},
+	{
+		"Video Borders   %s\n", //Name with string table
+		"Video borders   %d\n", //Name with integer
+		OSD_BORDERS, //Type of value
+		0, //Minimum value to use strings
+		1, //Maximum value to use strings
+		TABLE_ONOFF //String table
+	},
+	{
+		"Video bit depth %s\n", //Name with string table
+		"Video Bit Depth %d\n", //Name with integer
+		OSD_BITDEPTH, //Type of value
+		0, //Minimum value to use strings
+		1, //Maximum value to use strings
+		TABLE_BITDEPTH //String table
+	},
+	{
+		"\n", //Name with string table
+		"\n", //Name with integer
+		OSD_NONE, //Type of value
+		1, //Minimum value to use strings
+		-1, //Maximum value to use strings
+		0 //String table
+	},
+	{
+		"Reverb mode     %s\n", //Name with string table
+		"Reverb Mode     %d\n", //Name with integer
+		OSD_REVMODE, //Type of value
+		0, //Minimum value to use strings
+		9, //Maximum value to use strings
+		TABLE_REVMODE //String table
+	},
+	{
+		"Reverb volume   %s/127\n", //Name with string table
+		"Reverb volume   %d\n", //Name with integer
+		OSD_REVVOL, //Type of value
+		1, //Minimum value to use strings
+		-1, //Maximum value to use strings
+		0 //String table
+	},
+	{
+		"Reverb depth    %s/127\n", //Name with string table
+		"Reverb Depth    %d\n", //Name with integer
+		OSD_REVDEPTH, //Type of value
+		1, //Minimum value to use strings
+		-1, //Maximum value to use strings
+		0 //String table
+	},
+	{
+		"Reverb Delay    %s/127\n", //Name with string table
+		"Reverb delay    %d\n", //Name with integer
+		OSD_REVDELAY, //Type of value
+		1, //Minimum value to use strings
+		-1, //Maximum value to use strings
+		0 //String table
+	},
+	{
+		"Reverb Feedback %s/127\n", //Name with string table
+		"Reverb feedback %d\n", //Name with integer
+		OSD_REVFEEDBACK, //Type of value
+		1, //Minimum value to use strings
+		-1, //Maximum value to use strings
+		0 //String table
+	},
+	{
+		"\n", //Name with string table
+		"\n", //Name with integer
+		OSD_NONE, //Type of value
+		1, //Minimum value to use strings
+		-1, //Maximum value to use strings
+		0 //String table
+	},
+	{
+		"Time (Seq. Bytes)\n", //Name with string table
+		"Time (Seq. Bytes)\n", //Name with integer
+		OSD_ALTNONE, //Type of value
+		1, //Minimum value to use strings
+		-1, //Maximum value to use strings
+		0 //String table
+	},
+	{
+		"Minutes (4500B) %s\n", //Name with string table
+		"Minutes (1024B) %d\n", //Name with integer
+		OSD_MINUTES, //Type of value
+		1, //Minimum value to use strings
+		-1, //Maximum value to use strings
+		0 //String table
+	},
+	{
+		"Seconds (75 B.) %s\n", //Name with string table
+		"Seconds (16 B.) %d\n", //Name with integer
+		OSD_SECONDS, //Type of value
+		1, //Minimum value to use strings
+		-1, //Maximum value to use strings
+		0 //String table
+	},
+		{
+		"CD Frames (1B.) %s\n", //Name with string table
+		"CD Frames (1B.) %d\n", //Name with integer
+		OSD_FRAMES, //Type of value
+		1, //Minimum value to use strings
+		-1, //Maximum value to use strings
+		0 //String table
+	},
+	{
+		"*Set Time\n", //Name with string table
+		"*Set time\n", //Name with integer
+		OSD_SETTIME, //Type of value
+		1, //Minimum value to use strings
+		-1, //Maximum value to use strings
+		0 //String table
+	},
+	{
+		"\n", //Name with string table
+		"\n", //Name with integer
+		OSD_NONE, //Type of value
+		1, //Minimum value to use strings
+		-1, //Maximum value to use strings
+		0 //String table
+	},
+	{
+		"Minutes (4500B) %s\n", //Name with string table
+		"Seek Minutes    %d\n", //Name with integer
+		OSD_SEEKMINUTES, //Type of value
+		1, //Minimum value to use strings
+		-1, //Maximum value to use strings
+		0 //String table
+	},
+	{
+		"Seconds (75 B.) %s\n", //Name with string table
+		"Seek Seconds    %d\n", //Name with integer
+		OSD_SEEKSECONDS, //Type of value
+		1, //Minimum value to use strings
+		-1, //Maximum value to use strings
+		0 //String table
+	},
+		{
+		"CD Frames (1B.) %s\n", //Name with string table
+		"Seek Frames     %d\n", //Name with integer
+		OSD_SEEKFRAMES, //Type of value
+		1, //Minimum value to use strings
+		-1, //Maximum value to use strings
+		0 //String table
+	},
+	{
+		"\n", //Name with string table
+		"\n", //Name with integer
+		OSD_NONE, //Type of value
+		1, //Minimum value to use strings
+		-1, //Maximum value to use strings
+		0 //String table
+	},
+	{
+		"Repeat Delay    %s\n", //Name with string table
+		"Repeat Delay    %d Frames\n", //Name with integer
+		OSD_REPEATDELAY, //Type of value
+		1, //Minimum value to use strings
+		1, //Maximum value to use strings
+		TABLE_FRAMES //String table
+	},
+	{
+		"Repeat Speed    %s\n", //Name with string table
+		"Repeat Speed    %d Frames\n", //Name with integer
+		OSD_REPEATSPEED, //Type of value
+		1, //Minimum value to use strings
+		1, //Maximum value to use strings
+		TABLE_FRAMES //String table
+	},
+	{
+		"Display Time?   %s\n", //Name with string table
+		"Display Time?   %d\n", //Name with integer
+		OSD_DISPTIME, //Type of value
+		0, //Minimum value to use strings
+		1, //Maximum value to use strings
+		TABLE_ONOFF //String table
+	},
+	{
+		"*Set Tempo to:  %s\n", //Name with string table
+		"*Set tempo to:  %d\n", //Name with integer
+		OSD_TEMPO, //Type of value
+		1, //Minimum value to use strings
+		-1, //Maximum value to use strings
+		0 //String table
+	},
+	{
+		"Start Paused?   %s\n", //Name with string table
+		"Start Paused?   %d\n", //Name with integer
+		OSD_PAUSE, //Type of value
+		0, //Minimum value to use strings
+		1, //Maximum value to use strings
+		TABLE_ONOFF //String table
+	},
+	{
+		"Deallocate VAB? %s\n", //Name with string table
+		"Remove VB f/RAM?%d\n", //Name with integer
+		OSD_REALLOC, //Type of value
+		0, //Minimum value to use strings
+		1, //Maximum value to use strings
+		TABLE_ONOFF //String table
+	},
+	{
+		"Force Settings? %s\n", //Name with string table
+		"Force Settings? %d\n", //Name with integer
+		OSD_FORCE, //Type of value
+		0, //Minimum value to use strings
+		5, //Maximum value to use strings
+		TABLE_FORCE //String table
+	}
+};
+
+
+
 /* ---------------------------------------------------------------------------
  * - FUNCTION DEFINITIONS
  * ---------------------------------------------------------------------------
@@ -67,8 +467,9 @@ void InitControllers(void) {
 	InitPAD((char *) &buffers[0], MAX_CONTROLLER_BYTES, (char *) &buffers[1], MAX_CONTROLLER_BYTES);
 	StartPAD();
 	ChangeClearPAD(0);
-
-
+	
+	block = p.repeatspeed;
+	
 	VSync(0);
 	CheckControllers();
 }
@@ -122,7 +523,7 @@ void CheckControllers(void) {
 
 /* ------------------------------------------------------------------------ */
 
-short Pressed(short button) {
+u_short BPressed(u_short button) {
 
 
 /* - Type:	PUBLIC 
@@ -134,8 +535,256 @@ short Pressed(short button) {
  * - Usage:	Test if button has been pressed. 
  */
 
-
 	return (connected && !(buffers[currController].data.pad & button));
 }
 
 /* ------------------------------------------------------------------------ */
+
+
+short SetBlock() {
+	//u_short curPressed = buffers[currController].data.pad;
+	//printf("Last:%X Cur:%X Same:%i ", lastPressed, buffers[currController].data.pad, buffers[currController].data.pad == lastPressed);
+	int frametime = VSync(-1) - prev_vsync;
+	prev_vsync = VSync(-1);
+	//printf("frame time: %i\n", frametime);
+	if (buffers[currController].data.pad == lastPressed) {
+		hPressed += constrain(hPressed, 0, 32000);
+		if (block) {
+			block = constrain(block - frametime, 0, 32000);
+		} else {
+			if (repeats) {
+				repeats--;
+				block = p.inputspeed;
+			} else {
+				block = p.repeatspeed;
+			}
+		}
+	} else {
+		lastPressed = buffers[currController].data.pad;
+		ResetBlock(0);
+	}
+	//printf("Block Set To:%i\n", block);
+	return block;
+}
+
+short ResetBlock(short rblock) {
+	block = rblock;
+	repeats = REPEAT_DELAY;
+	hPressed = 0;
+	return block;
+}
+
+u_short Pressed(u_short button) {
+	//printf("Block: %i Pressed: %i BlockPressed: %i\n", block, BPressed(button), !block && BPressed(button));
+	return (!block && BPressed(button));
+}
+
+u_short RPressed(u_short button) {
+	return BPressed(button) * hPressed;
+}
+
+int VSyncGetCurrent() {
+	if (p.vsyncPauseBase) {
+		return p.vsyncPauseBase;
+	} else {
+		return VSync(-1);
+	}
+}
+
+
+/*char* TimeString() {
+	return 0; //sprintf the time string and return it. use static array
+} //also use vsync in the normal play modes*/
+
+void ShowTime(u_char type) {
+	int vsyncCurrent; //Display for stopped time
+	//static int hl = 0, os = 0;
+	switch (type)
+	{
+		case MUSIC_MOD:
+			FntPrint("\nSong Position:%3d/%d Pattern Position:%3d Pattern:%3d Channels: %d\n",
+			*MOD_CurrentOrder, seqLength - 1, *MOD_CurrentRow, *MOD_CurrentPattern, seqVoices);
+			break;
+		case MUSIC_XM:
+			vsyncCurrent = CurrentTime(type);// + 1;
+			FntPrint("\nSong Position:%3d/%d Pattern Position:%3d Pattern:%3d Channels: %d\n",
+			vsyncCurrent, seqLength - 1, Feedback.PatternPos, Feedback.CurrentPattern, Feedback.ActiveVoices);
+			break;
+		case MUSIC_VAG:
+			FntPrint("\nDefault Sample Rate: %d Hz\n", seqLength);
+			break;
+		case MUSIC_STR:
+		case MUSIC_STR1X:
+		case MUSIC_STR2X:
+		case MUSIC_XA:
+		case MUSIC_XA1X:
+		case MUSIC_XA2X:
+		case MUSIC_DA:
+			//if (1) //(StreamPlaying != 2)
+			//{
+			vsyncCurrent = VSyncGetCurrent() - p.vsyncBase;
+			FntPrint("\nTime: %d:%d%d", 
+			VSyncMinutes(vsyncCurrent), VSyncTens(vsyncCurrent), VSyncOnes(vsyncCurrent));
+			if (p.endVSync)
+			{
+				FntPrint("/%d:%d%d\n", VSyncMinutes(p.endVSync), VSyncTens(p.endVSync), VSyncOnes(p.endVSync));
+			}
+			else
+			{
+				FntPrint("\n");
+			}
+			//}
+			break;
+		case MUSIC_NEWSEQ:
+			if (seqLength)
+			{
+				FntPrint("\nSequence Bytes: %d/%d\n", CurrentTime(type), seqLength);
+			}
+			break;
+	}
+}
+
+u_char drawOSDList(int highlight, int offset)
+{
+	//int number = 1;
+	int ctr=0;
+	int gotNumber = 0;
+	int fileNumber=0;
+	int numDisplayFiles=VIEWFILES;
+
+	if(numDisplayFiles > OSDTYPES)
+		numDisplayFiles = OSDTYPES;
+
+		fileNumber+=offset;
+		FntPrint("Options %d to %d of %d options\n",(1+offset),(numDisplayFiles+offset), OSDTYPES);
+		for(ctr=0;ctr<numDisplayFiles;ctr++)
+		{
+			if (ctr == highlight)
+			{
+				FntPrint("~c880-> ");
+			}
+			else	
+			{
+				FntPrint("   ");
+			}
+			gotNumber = OSDGetVal(OSDItems[fileNumber].type);
+			if (gotNumber >= OSDItems[fileNumber].stringmin && gotNumber <= OSDItems[fileNumber].stringmax)
+			{
+				FntPrint(OSDItems[fileNumber].name, OSDItems[fileNumber].strings[gotNumber - OSDItems[fileNumber].stringmin]);
+			}
+			else
+			{
+				FntPrint(OSDItems[fileNumber].intname, gotNumber);
+			}
+			fileNumber++;
+			if (ctr == highlight)
+			{
+				FntPrint("~c888");
+			}
+		}
+
+		return(OSDItems[highlight+offset].type);
+}
+
+void MoveHighlightOSD(int i, int *highlight, int *offset)
+{
+	if (i > 0) {
+		while (*highlight+*offset+i < OSDTYPES && OSDItems[*highlight+*offset+i].type == OSD_NONE) {
+			i++;
+		}
+	} else {
+		while (*highlight+*offset+i > 0 && OSDItems[*highlight+*offset+i].type == OSD_NONE) {
+			i--;
+		}
+	}
+	MoveHighlight(i, OSDTYPES, highlight, offset);
+}
+
+int VSyncSeconds (int vsyncs) {
+	if (*(char *)0xbfc7ff52=='E') {
+		return (vsyncs / 50) % 60;
+	} else {
+		return (vsyncs / 60) % 60;
+	}
+}
+
+int VSyncMinutes (int vsyncs) {
+	if (*(char *)0xbfc7ff52=='E') {
+		return (vsyncs / 50) / 60;
+	} else {
+		return (vsyncs / 60) / 60;
+	}
+}
+
+int VSyncTens (int vsyncs) {
+	if (*(char *)0xbfc7ff52=='E') {
+		return ((vsyncs / 50) % 60) / 10;
+	} else {
+		return ((vsyncs / 60) % 60) / 10;
+	}
+}
+
+int VSyncOnes (int vsyncs) {
+	if (*(char *)0xbfc7ff52=='E') {
+		return (vsyncs / 50) % 10;
+	} else {
+		return (vsyncs / 60) % 10;
+	}
+}
+
+/*
+*
+*       NAME		MoveHighlight(int i, int numFiles)
+*
+*       FUNCTION	Process users directional buttons
+*
+*       NOTES		Function controls highlight processing
+*
+*       CHANGED		PROGRAMMER      REASON
+*       -------		----------      ------
+*       20/03/98	Mike Kav        Created
+*
+*/
+
+void MoveHighlight(int i, int numFiles, int *highlight, int *offset)
+{
+	int displayFiles = VIEWFILES;
+
+	// Check that we have greater than ten files to view
+	// if not then set the displayed files correctly
+	if(displayFiles > numFiles)
+		displayFiles = numFiles;
+	
+	if (*highlight + i < 0) //negative numbers (up by i)
+	{
+		if (*offset + i < 0)
+		{
+			*offset = 0;
+			*highlight = 0;
+		}
+		else
+		{
+			*offset += i;
+		}
+	}
+	else if (*highlight + i >= displayFiles) //positive numbers (down by i)
+	{
+		if (*offset + i >= numFiles - displayFiles)
+		{
+			*offset = numFiles - displayFiles;
+			*highlight = displayFiles - 1;
+		}
+		else
+		{
+			*offset += i;
+		}
+	}
+	else
+	{
+		*highlight += i;
+	}
+
+
+
+	return;
+}
\ No newline at end of file
diff --git a/CONTROL.H b/CONTROL.H
index 089a8bc..3e1691e 100644
--- a/CONTROL.H
+++ b/CONTROL.H
@@ -58,8 +58,41 @@ void CheckControllers(void);
 
 /* ------------------------------------------------------------------------ */
 
-short Pressed(short button);
+u_short Pressed(u_short button);
 
 /* ------------------------------------------------------------------------ */
 
+typedef struct {
+	char* name;
+	char* intname;
+	u_char type; //makes things easier
+	//int min; //min and max are constrained by getOSDValue
+	//int max;
+	int stringmin;
+	int stringmax;
+	char** strings;
+} OSDITEM;
+
+/*
+ParamsV3: All params for OSD
+numFiles
+INPUT_DELAY
+Seek Time
+Direct Jump In File
+Reverb Delay Frames
+Start Song Before Reverb Delay Flag
+*/
+void MoveHighlight(int i, int numFiles, int *highlight, int *offset);
+void ShowTime(u_char type);
+//short GetBlock();
+short SetBlock();
+short ResetBlock(short rblock);
+u_short BPressed(u_short button);
+u_short RPressed(u_short button);
+int VSyncSeconds (int vsyncs);
+int VSyncMinutes (int vsyncs);
+int VSyncGetCurrent();
+u_char drawOSDList(int highlight, int offset);
+void MoveHighlightOSD(int i, int *highlight, int *offset);
+//char* TimeString();
 #endif // __CONTROL_H 
diff --git a/HITMOD.H b/HITMOD.H
new file mode 100644
index 0000000..740ee59
--- /dev/null
+++ b/HITMOD.H
@@ -0,0 +1,46 @@
+/**************************************************************************** 
+ *                      HITMOD PlayStation MODPlayer                        * 
+ *                              version 1.5                                 * 
+ *                           by Silpheed/HITMEN                             *  
+ *                                                                          *  
+ ****************************************************************************/
+
+void MOD_Init(void);
+/**************************************************************************** 
+ * MOD_Init(): Call this first to initialise the player and the SPU etc..   * 
+ *                                                                          * 
+ ****************************************************************************/
+ 
+int MOD_Load(unsigned char*);
+/**************************************************************************** 
+ * MOD_Load(): Call this with the address of a HITMOD module to prepare it  * 
+ *             for playback. Returns 1 for success, 0 for failure           * 
+ ****************************************************************************/
+ 
+void MOD_Start(void);
+/**************************************************************************** 
+ * MOD_Start(): Starts the module playing.                                  * 
+ *                                                                          * 
+ ****************************************************************************/
+
+void MOD_Stop(void);
+/**************************************************************************** 
+ * MOD_Stop(): Stops playback. Can resume playing again with MOD_Start().   * 
+ *                                                                          * 
+ ****************************************************************************/
+
+void MOD_Free(void);
+/**************************************************************************** 
+ * MOD_Free(): Frees up memory used by MOD_Load, allowing you to load       * 
+ *             another module.                                              * 
+ ****************************************************************************/
+
+ 
+extern int *MOD_CurrentPattern;     /* Current pattern being played */
+extern int *MOD_CurrentRow;         /* Current row being played */
+extern int *MOD_CurrentOrder;       /* Current order being played */
+
+/* the following three are arrays - [0 to No.Channels-1] */
+extern int *MOD_Volume;            /* Current sample volume of each channel */
+extern int *MOD_Freq;              /* Current frequency (note) of each channel */            
+extern int *MOD_LastSample;        /* Last sample played on each channel */
diff --git a/HITMOD.OBJ b/HITMOD.OBJ
new file mode 100644
index 0000000000000000000000000000000000000000..2420d4e5711e02442007960aeb7858d65e3ec2af
GIT binary patch
literal 15830
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
Ptl$=B(}vC-J@NEEWl{*W

literal 0
HcmV?d00001

diff --git a/MAIN.C b/MAIN.C
index 6d6787e..543c1dd 100644
--- a/MAIN.C
+++ b/MAIN.C
@@ -23,18 +23,27 @@
 #include <libsnd.h>
 #include <libgs.h>
 
+#include <malloc.h>
+#include <xmplay.h>
+
 #include "main.h"
 #include "sceecd.h"
+//#include "state.h"
 #include "control.h"
 #include "movie.h"
 #include "timview.h"
+#include "music.h"
 
+//#include "hitmod.h" HITMOD VOLSUMES ARE 0-127. THEY DON't HELP.
 // Maximum Volume
 #define MAX_VOL				127
-#define INPUT_DELAY			5
+
 
 #define VIEWFILES			10
 
+#define FORM1_SIZE     2048 
+#define Sectors(x) ((x+FORM1_SIZE-1)/FORM1_SIZE)
+
 #ifdef FINAL
 u_long _ramsize   = 0x00200000;				// Use 2MB for final.
 u_long _stacksize = 0x00004000;
@@ -43,8 +52,14 @@ u_long _ramsize   = 0x00800000;				// Use 8MB for development.
 u_long _stacksize = 0x00008000;
 #endif
 
+#ifdef BINMENU
 extern unsigned long pictureTIM[];			// picture inbin'd from
-											// test.tim
+#endif											// test.tim
+
+int LoadPimp(u_char* buf, EXTENDEDFILEDETAILS* menu, FULLFILENAME* names, int max);
+int LoadLoser(u_char* buf, EXTENDEDFILEDETAILS* menu, FULLFILENAME* names, int max);
+int LoadPsf(u_char* buf, EXTENDEDFILEDETAILS* menu, FULLFILENAME* names, int max);
+
 // Polygon details for displaying texture
 POLY_FT4 poly;
 int polyWidth;
@@ -52,8 +67,14 @@ int polyHeight;
 int tpage_x, tpage_y;
 TEXTURE_INFO texture;
 
+static void		InitSys(void); 
+static void		CloseSys(void);
+static void		ClearVRAM(void);
+
+int GetBasePos(u_long type, char* filename, u_char mtype, int pos, VFSFILE* vf);
+int GetBaseSize(u_long type, u_char mtype, VFSFILE* vf);
 
-static volatile long frameNo = 0;			// Current frame No.
+static volatile u_long frameNo = 0;			// Current frame No.
 DB		db[2];		
 short	cdb = 0;							// Current double buffer.
 
@@ -63,32 +84,119 @@ long	fIdA;								// Applic font id.
 int offset = 0;
 int highlight = 0;
 
+char default_title[] = "Game Idiot v1.5";
+char* title = default_title;
+char custom_title[64];
+
+const char* const type_strings[] = {
+	"HITMOD Module",
+	"Packed VAB+XM (Jason Page)",
+	"STR Video",
+	"PSX-EXE File",
+	"SEQ Audio",
+	"XA Audio File",
+	"XA Audio Track",
+	"Directory",
+	"VFS Archive",
+	"TXT Menu",
+	"PSFMenu TXT Menu",
+	"Loser's Boot Menu TXT",
+	"CDDA Track Menu",
+	"CDDA Track",
+	"TIM Image",
+	"PSX Game SYSTEM.CNF",
+	"P.I.M.P. Video Menu",
+	"PSX-EXE (New Stack)",
+	"PSX-EXE (New Stack+Size)",
+	"STR Video (1X Speed)",
+	"STR Video (2X Speed)",
+	"XA Audio File (1X Speed)",
+	"XA Audio Track (1X Speed)",
+	"XA Audio File (2X Speed)",
+	"XA Audio Track (2X Speed)",
+	"VFS Archive (Sector Sizes)",
+	"VFS Archive (Byte Sizes)",
+	"VAG Audio Sample"
+}; //can load paramaters using force settings so thats really not needed since it wont be used often
+
+#define NUM_TYPES 28
+
+const u_char menu_types[] = {
+	MUSIC_MOD,
+	MUSIC_XM,
+	MUSIC_STR,
+	MUSIC_NEWEXE,
+	MUSIC_NEWSEQ,
+	MENU_XA,
+	MUSIC_XA,
+	MENU_DIR,
+	MENU_VFS,
+	MENU_TXT,
+	MENU_TXTPSF,
+	MENU_TXTLOSER,
+	MENU_DA,
+	MUSIC_DA,
+	MUSIC_TIM,
+	MUSIC_CNF,
+	MENU_TXTPIMP,
+	MUSIC_EXE,
+	MUSIC_ZEROEXE,
+	MUSIC_STR1X,
+	MUSIC_STR2X,
+	MENU_XA1X,
+	MUSIC_XA1X,
+	MENU_XA2X,
+	MUSIC_XA2X,
+	MENU_VFSSECTOR,
+	MENU_VFSBYTE,
+	MUSIC_VAG
+};
+
 // Last directory successfully displayed
 int lastDir=0;
 int lastDirLength=0;
 
+int lastDir1[64];
+int lastDirLength1[64];
+u_char lastDirType1[64];
+short lastDirLevel = 0;
+
+short SCREEN_X, SCREEN_Y, FRAME_X, FRAME_Y;
+
 // Root directory info
 int startSec,secLength, numFiles;
+//int numFullNames = 0;
 
 // Set up array for holding file details, this should be dynamic
 // but I'm lazy
-#define MAXFILES 500
-EXTENDEDFILEDETAILS fileDetails[MAXFILES];
+#define MAXFILES 5000
+//EXTENDEDFILEDETAILS gDetails[MAXFILES];
+EXTENDEDFILEDETAILS* fileDetails;
+FULLFILENAME* fullNames = 0;
 
 // MAX 8 directory levels + filename + separators
 char currentPath[((8*8)+15+9)];
+char autorun = 0;
 
 // Stream values, ready for stream viewer
-short	streamMode = STR_MODE24,
-		borders = STR_BORDERS_ON,
-		volume = MAX_VOL;
+
+extern ParamsShared p;
+extern int seqMin;
+extern int seqLength;
+extern u_char seqSpeed;
+extern u_long XAChannels;
 
 int main(void)
 {
-	short	block = INPUT_DELAY;
-
+	//short	block = 0;
 	int currentFile;
+	
+	
+	InitHeap3((void*)__heapbase, __heapsize);
 
+	#if DEBUG
+	//printf("IdiotRom %i bytes free\n", __heapsize);
+	#endif
 	InitSys();
 	ClearVRAM();
 	InitEnvs(db);
@@ -98,35 +206,42 @@ int main(void)
 
 	PutDispEnv(&db[cdb].disp);
 	SetDispMask(1);
-
+	
 	if(!InitCDBrowser())
 		return;
-
 	while (1)
 	{
+		//SetBlock(); //Move to Vsync Callback - needs move stuff from music.c to control.c
 		cdb ^= 1;
 
-		FntPrint(fIdA, "CD Browser V1.0\n\n");
-
-		FntPrint(fIdA, "Stream Parameters\n", volume);		
-		FntPrint(fIdA, "L2,R2 Volume+/-\t= %d\n", volume);
-		FntPrint(fIdA, "L1       = Mode %s\n", (streamMode) ? "24Bit" : "16Bit");
-		FntPrint(fIdA, "R1       = Borders %s\n\n", (borders) ? "On" : "Off");
+		FntPrint(fIdA, title, __heapsize);
+		FntPrint(fIdA, "\n\n", title);
 
+		FntPrint(fIdA, "Pad Up/Down - Move 1\t  Pad Left/Right - Move 10\n");		
+		FntPrint(fIdA, "L1/R1 Volume-/+ = %3d\t L2/R2 - Seek\n", p.volume);
+		FntPrint(fIdA, "Triangle - Directory Up   Square - File Info\n");
+		FntPrint(fIdA, "O - Play/Pause\t\t\tSelect - Swap Disc\n");
+		FntPrint(fIdA, "Start - Show OSD (Settings/Resolution)\n\n");
 		// Now print directory listing
 		currentFile = drawFileList(numFiles);
-
-		if (Pressed(SQUARE_KEY))
+		if (p.displaytime && StreamPlaying != 2)
+		{
+			ShowTime(MusicType);
+		}
+		//block = 0;
+		//SetBlock();
+		
+		if (Pressed(SELECT_KEY))
 		{
-			SwapDisk();
+			CdStopMusic(MusicType);
+			SwapDisk(0);
 			InitCDBrowser();
 		}
-		else if (Pressed(TRIANGLE_KEY))
+		else if (Pressed(START_KEY))
 		{
-			;
-//			printf("Triangle");
+			displayOSD();
 		}
-		else if (Pressed(CIRCLE_KEY))
+		else if (Pressed(SQUARE_KEY))
 		{
 			displayFileDetails(currentFile);
 		}
@@ -135,42 +250,63 @@ int main(void)
 			// If the lid is up wait for the lid to shut, check disk
 			// and reload root directory
 			IsCdReady();
-			numFiles = selectEntry(currentFile);
+			ParseFileType(currentFile, 0);
+			ResetBlock(32000);
+		}
+		else if (Pressed(TRIANGLE_KEY))
+		{
+			IsCdReady();
+			ParseFileType(1, 0); //..
+			ResetBlock(32000);
 		}
 		else if (Pressed(R2_KEY))
 		{
-			volume += 2;
-			if (volume > MAX_VOL)
-				volume = MAX_VOL;
+			SeekMusic(MusicType, 0, p.seekframes, seqMin, seqMin + seqLength, p.seekseconds, p.seekminutes, seqSpeed);
+			ResetBlock(32000);
+		}
+		else if (Pressed(L2_KEY)) 
+		{
+			SeekMusic(MusicType, 0, -p.seekframes, seqMin, seqMin + seqLength, -p.seekseconds, -p.seekminutes, seqSpeed);
+			ResetBlock(32000);
+		}
+		else if (Pressed(UP_KEY))
+		{
+			MoveHighlight(-1,numFiles, &highlight, &offset);
+			//block = INPUT_DELAY;
+		}
+		else if (Pressed(DOWN_KEY))
+		{
+			MoveHighlight(1,numFiles, &highlight, &offset);
+			//block = INPUT_DELAY;
 		}
-		else if (Pressed(L2_KEY)) {
-			volume -= 2;
-			if (volume < 0)
-				volume = 0;
+		else if (Pressed(LEFT_KEY))
+		{
+			MoveHighlight(-10,numFiles, &highlight, &offset);
+			//block = INPUT_DELAY;
 		}
-		else if (!block && Pressed(UP_KEY))
+		else if (Pressed(RIGHT_KEY))
 		{
-			MoveHighlight(1,numFiles);
-			block = INPUT_DELAY;
+			MoveHighlight(10,numFiles, &highlight, &offset);
+			//block = INPUT_DELAY;
 		}
-		else if (!block && Pressed(DOWN_KEY))
+		else if (Pressed(L1_KEY))
 		{
-			MoveHighlight(0,numFiles);
-			block = INPUT_DELAY;
+			p.volume = SetVolume(p.volume - 1, MusicType);
+			//block = INPUT_DELAY;
 		}
-		else if (!block && Pressed(L1_KEY))
+		else if (Pressed(R1_KEY))
 		{
-			streamMode = (streamMode == STR_MODE24) ? STR_MODE16 : STR_MODE24;	
-			block = INPUT_DELAY;
+			p.volume = SetVolume(p.volume + 1, MusicType);
+			//block = INPUT_DELAY;
 		}
-		else if (!block && Pressed(R1_KEY))
+		else if (Pressed(CIRCLE_KEY))
 		{
-			borders = (borders == STR_BORDERS_ON) ? STR_BORDERS_OFF : STR_BORDERS_ON;	
-			block = INPUT_DELAY;
+			PlayPauseMusic(MusicType);
+			ResetBlock(32000);
 		}
 
-		if (block > 0)
-			block--;
+		//if (block > 0)
+			//block--;
 
 //	int polyY=0;
 //	int polyX=20;
@@ -187,7 +323,8 @@ int main(void)
 		PutDrawEnv(&db[cdb].draw);
 		PutDispEnv(&db[cdb].disp);
 	}
-
+	
+	free3(fileDetails);
 	CloseSys();
 	return 0;
 }
@@ -213,12 +350,24 @@ static void InitSys(void)
 	SetGraphDebug(0);
 	CdInit();
 
-	// Video Mode.
-	SetVideoMode(MODE_PAL);
+	// Video Mode. 
+	if (*(char *)0xbfc7ff52=='E') {
+		FRAME_X = 640; //needed for 64 character file names
+		FRAME_Y = 256;
+		SCREEN_X = 0;
+		SCREEN_Y = 18; //16 or 18?
+		SetVideoMode(MODE_PAL);
+	} else {
+		FRAME_X = 640;
+		FRAME_Y = 240;
+		SCREEN_X = 0;
+		SCREEN_Y = 0;
+		SetVideoMode(MODE_NTSC);
+	}
 
 	InitGeom();
 	InitControllers();
-	SndInit();
+	//SndInit();
 	VSyncCallback((void (*)()) VSyncCB);
 
 }
@@ -277,91 +426,11 @@ void InitEnvs(DB *db)
 
 	// Init font environment.
 	FntLoad(960, 256);	
-	fIdA = FntOpen(18, 16, 310, 200, 0, 1024);			// Applic stream.
+	fIdA = FntOpen(18, 16, 600, 200, 0, 1024);			// Applic stream.
 	SetDumpFnt(fIdA);	
 }
 
-/*
-*
-*       NAME		void SndInit(void)
-*
-*       FUNCTION	Init sound system and volumes.
-*
-*       NOTES		
-*
-*       CHANGED		PROGRAMMER      REASON
-*       -------		----------      ------
-*       20/03/98	Mike Kav        Created
-*
-*/
-void SndInit(void)
-{
-
-	CdlATV	aud;
-	char	result[8];
-
-	aud.val0 = 127;
-	aud.val1 = 127;
-	aud.val2 = 127;
-	aud.val3 = 127;
-
-	CdControl(CdlDemute, NULL, result);
-	CdControlB(CdlSetfilter, NULL, result);
-	CdMix(&aud);
-
-	// Clear last 100K of SPU RAM (i.e. maximum reverb workarea). 
-	SpuInit();
-	SpuSetTransStartAddr(421887);
-	SpuWrite0(1024 * 100);
-
-	SsInit();
-
-	SsUtReverbOff();
-	SsUtSetReverbType(0);
-	SsUtSetReverbDepth(0, 0);
-
-	SsSetTickMode(SS_TICKVSYNC);
-	SsSetMVol(127, 127);
-
-	SsSetSerialAttr(SS_SERIAL_A, SS_MIX, SS_SON);
-	SsSetSerialVol(SS_SERIAL_A, 127, 127);
-
-	SsUtSetReverbType(SS_REV_TYPE_STUDIO_B);
-	SsUtReverbOn();
-	VSync(75);						//Delay for a while =;-D
-	SsUtSetReverbDepth(40, 40);
-}
-
-/*
-*
-*       NAME		void SndShutDown(void)
-*
-*       FUNCTION	Shut down the sound system, clear
-*					reverb buffer etc
-*
-*       NOTES		
-*
-*       CHANGED		PROGRAMMER      REASON
-*       -------		----------      ------
-*       20/03/98	Mike Kav        Created
-*
-*/
-void SndShutDown(void)
-{
-
-    SsUtReverbOff();
-    SsUtSetReverbType(0);
-    SsUtSetReverbDepth(0,0);
-
-    // Clear last 100K of SPU RAM (i.e. maximum reverb workarea). 
-    SpuSetTransStartAddr(421887);
-    SpuWrite0(1024 * 100);
-
-	// Wait until SPU RAM cleared.
-	VSync(100);
-
-    SsEnd();            
-} 	
+	
 
 /*
 *
@@ -377,11 +446,57 @@ void SndShutDown(void)
 *       20/03/98	Mike Kav        Created
 *
 */
-static void VSyncCB(void)
+void VSyncCB(void)
 {
-
+	u_char result[8];
+	//printf("SetBlock Type %X\n", MusicType, StreamPlaying);
+	switch (MusicType) {
+		case MUSIC_STR: //Block set in player or it doesn't work
+		case MUSIC_STR1X:
+		case MUSIC_STR2X:
+			//printf("Playing:%i ",StreamPlaying);
+			if (StreamPlaying == 2)
+			{
+				SetBlock();
+			}
+			//vsyncCount++;
+			break;
+		case MUSIC_XM:
+			XM_Update();
+			SetBlock();
+			break;
+		case MUSIC_NEWSEQ:
+			if (!p.tickmode) //SS_NOTICK
+			{
+				SsSeqCalledTbyT();
+			}
+			SetBlock();
+			break;
+		//case MUSIC_MOD:
+		//	printf("1:%i 2:%i 3:%i 4:%i\n", MOD_Volume[0], MOD_Volume[1], MOD_Volume[2], MOD_Volume[3]);
+		case MUSIC_DA:
+			if (p.force < 4)
+			{
+				switch (CdReady(1, result))
+				{
+					case CdlDiskError:
+						UnloadMusic(MusicType);
+						break;
+				}
+				if (p.endVSync && StreamPlaying == 1 && (VSyncGetCurrent() - p.vsyncBase) - p.endVSync >= 30)
+				{
+					printf("Stopping CD\n");
+					UnloadMusic(MusicType);
+					StreamPlaying = 2;
+				}
+			}
+			SetBlock();
+			break;
+		default:
+			SetBlock();
+			break;
+	}
 	frameNo++;
-
 	if (!(frameNo % CHECK_CONTROLLERS))
 		CheckControllers();
 }
@@ -418,111 +533,6 @@ void ClearVRAM(void)
 	DrawSync(0); // Ensure VRAM is cleared before exit.
 }
 
-
-/*
-*
-*       NAME		int selectEntry(int currentFile)
-*
-*       FUNCTION	Process users file selection
-*
-*       NOTES		Function either passes the file number
-*					to ParseFileType() if it is a file. If
-*					it is a directory the new directory
-*					details are created. Function returns
-*					the number of files in the current
-*					directory
-*
-*       CHANGED		PROGRAMMER      REASON
-*       -------		----------      ------
-*       20/03/98	Mike Kav        Created
-*
-*/
-int selectEntry(int currentFile)
-{
-	char endString[6];
-	int numFiles,startSec,secLength;
-
-	// get last two characters of selected file
-	strncpy(endString,(fileDetails[currentFile].filename+strlen(fileDetails[currentFile].filename)-2),2);
-	endString[2] = '\0';
-	if( strcmp(endString,";1")==0 )
-	{
-		strncpy(endString,(fileDetails[currentFile].filename+strlen(fileDetails[currentFile].filename)-5),5);
-		endString[5] = '\0';
-		ParseFileType(endString,currentFile);
-	}
-	else
-	{
-		// Its a directory, rebuild directory view
-		highlight = 0;
-		offset = 0;
-		startSec = fileDetails[currentFile].pos;
-		secLength = (fileDetails[currentFile].size / 2048);
-
-		lastDir			= startSec;
-		lastDirLength	= secLength;
-
-		CreatePath(fileDetails[currentFile].filename);
-	}
-
-	numFiles = GetNumDirEntries(lastDir,lastDirLength);
-	if(numFiles > MAXFILES)
-		printf("** Time to increase fileDetails structure\n");
-	
-	GetDirDetails(lastDir,lastDirLength);
-	return numFiles;
-}
-
-/*
-*
-*       NAME		MoveHighlight(int i, int numFiles)
-*
-*       FUNCTION	Process users directional buttons
-*
-*       NOTES		Function controls highlight processing
-*
-*       CHANGED		PROGRAMMER      REASON
-*       -------		----------      ------
-*       20/03/98	Mike Kav        Created
-*
-*/
-void MoveHighlight(int i, int numFiles)
-{
-	int displayFiles = VIEWFILES;
-
-	// Check that we have greater than ten files to view
-	// if not then set the displayed files correctly
-	if(displayFiles > numFiles)
-		displayFiles = numFiles;
-
-	// up
-	if(i==1)
-	{
-		// Check if we are at top of list
-		if(highlight == 0)
-		{
-			if( offset > 0)
-				offset--;
-		}
-		else
-			highlight--;
-	}
-	// down
-	if(i==0)
-	{
-		// Check if we are at bottom of list
-		if(highlight == (displayFiles-1))
-		{
-			if( offset < (numFiles-VIEWFILES))
-				offset++;
-		}
-		else
-			highlight++;
-	}
-
-	return;
-}
-
 /*
 *
 *       NAME		int drawFileList(int numFiles)
@@ -541,7 +551,7 @@ int drawFileList(int numFiles)
 {
 	int number = 1;
 	int ctr=0;
-	char test[6];
+
 	int fileNumber=0;
 	int numDisplayFiles=VIEWFILES;
 
@@ -551,33 +561,65 @@ int drawFileList(int numFiles)
 
 		fileNumber+=offset;
 		number+=offset;
-		FntPrint("Files %2d to %d of %d files\n",(1+offset),(numDisplayFiles+offset),numFiles);
+		FntPrint("Files %d to %d of %d files\n",(1+offset),(numDisplayFiles+offset),numFiles);
 
 		FntPrint("%s\n\n",currentPath);		
 		for(ctr=0;ctr<numDisplayFiles;ctr++)
 		{
 			if(highlight == ctr)
-			FntPrint("\t~c800%2d:%s~c888\n",number++,fileDetails[fileNumber].filename);
+			FntPrint("  ->~c800%4d:%s~c888\n",number++,fileDetails[fileNumber].name); //RED - HIGHLIGHTED
 			else
 			{
-				strncpy(test,(fileDetails[fileNumber].filename+strlen(fileDetails[fileNumber].filename)-5),5);
-				test[5] = '\0';
-				if( strcmp(test,"STR;1") == 0 )			
-					FntPrint("\t~c080%2d:%s~c888\n",number++,fileDetails[fileNumber].filename);
-				else
+				switch(fileDetails[fileNumber].type)
 				{
-					strncpy(test,(fileDetails[fileNumber].filename+strlen(fileDetails[fileNumber].filename)-2),2);
-					test[2]='\0';
-
-					if(strcmp(test,";1") != 0)
-					{
-						FntPrint("\t~c880%2d:%s~c888\n",number++,fileDetails[fileNumber].filename);
-					}
-					else
-					{
-						FntPrint("\t%2d:%s\n",number++,fileDetails[fileNumber].filename);
-					}
+					case MUSIC_MOD:
+					case MUSIC_XM:
+					case MUSIC_NEWSEQ:
+					case MUSIC_SEQONLY:
+					case MUSIC_PARAMS:
+					case MUSIC_XA:
+					case MUSIC_XA1X:
+					case MUSIC_XA2X:
+					case MUSIC_DA:
+					case MUSIC_VAG:
+						FntPrint("\t~c088%4d:%s~c888\n",number++,fileDetails[fileNumber].name); //CYAN - MUSIC
+						break;
+					case MUSIC_TIM:
+						FntPrint("\t~c044%4d:%s~c888\n",number++,fileDetails[fileNumber].name); //CYAN - TIM
+						break;
+					case MUSIC_STR:
+					case MUSIC_STR1X:
+					case MUSIC_STR2X:
+						FntPrint("\t~c080%4d:%s~c888\n",number++,fileDetails[fileNumber].name); //GREEN - VIDEO
+						break;
+					case MUSIC_EXE:
+					case MUSIC_NEWEXE:
+					case MUSIC_ZEROEXE:
+					case MUSIC_CNF:
+						FntPrint("\t~c808%4d:%s~c888\n",number++,fileDetails[fileNumber].name); //MAGENTA - EXE
+						break;
+					case MENU_DIR:
+					case MENU_LASTDIR:
+						FntPrint("\t~c880%4d:%s~c888\n",number++,fileDetails[fileNumber].name); //YELLOW - DIRECTORY
+						break;
+					case MENU_DA:
+					case MENU_XA:
+					case MENU_XA1X:
+					case MENU_XA2X:
+					case MENU_VFS:
+					case MENU_VFSBYTE:
+					case MENU_VFSSECTOR:
+					case MENU_TXT:
+					case MENU_TXTLOSER:
+					case MENU_TXTPSF:
+					case MENU_TXTPIMP:
+						FntPrint("\t~c440%4d:%s~c888\n",number++,fileDetails[fileNumber].name); //YELLOW - PACKED DIRECTORY
+						break;
+					default:
+						FntPrint("\t%4d:%s\n",number++,fileDetails[fileNumber].name); //WHITE - OTHER
+						break;
 				}
+
 			}
 
 			fileNumber++;
@@ -586,100 +628,47 @@ int drawFileList(int numFiles)
 		return(highlight+offset);
 }
 
-/*
-*
-*       NAME		void ParseFileType(char *string,int currentFile)
-*
-*       FUNCTION	Used to hook in viewers, currently only TIM 
-*					viewer is supported
-*
-*       NOTES		
-*
-*       CHANGED		PROGRAMMER      REASON
-*       -------		----------      ------
-*       20/03/98	Mike Kav        Created
-*
-*/
-void ParseFileType(char *string,int currentFile)
+int drawTypeList(int numTypes, int highlight, int offset)
 {
-	if( strcmp(string,"STR;1")==0 )
-	{
-		InitStream(currentFile);
-	}
-	else if( strcmp(string,"TIM;1")==0 )
-	{
-		TimViewer(fileDetails[currentFile]);
-	}
-	else
-		return;
-
-	InitPoly();
-	return;
-}
+	//int number = 1;
+	int ctr=0;
 
-/*
-*
-*       NAME		void displayFileDetails(int file)
-*
-*       FUNCTION	Display files name, size and position
-*
-*       NOTES		
-*
-*       CHANGED		PROGRAMMER      REASON
-*       -------		----------      ------
-*       20/03/98	Mike Kav        Created
-*
-*/
-void displayFileDetails(int file)
-{
 	int fileNumber=0;
-	char endString[3];
-	CdlLOC fp;
-
-	CdIntToPos(fileDetails[file].pos,&fp);
+	int numDisplayFiles=VIEWFILES;
 
-	while( !Pressed(TRIANGLE_KEY) )
-	{
-		cdb ^= 1;
+	// Normally display ten files, unless we have not got that many
+	if(numDisplayFiles > numTypes)
+		numDisplayFiles = numTypes;
 
 		fileNumber+=offset;
-				
-		strncpy(endString,(fileDetails[file].filename+strlen(fileDetails[file].filename)-2),2);
-		endString[2] = '\0';
-		if( strcmp(endString,";1")==0 )
-		{
-			FntPrint("File Details\n\n");
-			FntPrint("File = %s\n",fileDetails[file].filename);
-		}
-		else
+		//number+=offset;
+		FntPrint("File types %d to %d of %d types\n",(1+offset),(numDisplayFiles+offset), numTypes);
+
+		//FntPrint("123456789A123456789B123456789C123456789D123456789E123456789F123456789G1234\n");
+		//74 chars max in 600 pixel wide font draw area
+		for(ctr=0;ctr<numDisplayFiles;ctr++)
 		{
-			FntPrint("Directory Details\n\n");
-			FntPrint("Directory = %s\n",fileDetails[file].filename);
-		}
-		
-		FntPrint("Size = %d\n",fileDetails[file].size);
-		FntPrint("Absolute Position = %d\n",fileDetails[file].pos);
-		FntPrint("Position:\n");
-		FntPrint("\tMin:%02x,Sec:%02x,Sector:%02x\n",fp.minute,fp.second,fp.sector);
-		FntPrint("\nPress Triangle to continue\n");
+			if(highlight == ctr)
+			{
+				FntPrint(" -> ~c800Load as %s~c888\n",type_strings[fileNumber]); //RED - HIGHLIGHTED
+			}
+			else
+			{
+				FntPrint("\tLoad as %s\n",type_strings[fileNumber]); //NOT HIGHLIGHTER
+			}
 
-		DrawSync(0);
-		FntFlush(-1);
-		VSync(0);
+			fileNumber++;
+		} 
 
-		PutDrawEnv(&db[cdb].draw);
-		PutDispEnv(&db[cdb].disp);
-	}
-	
-	return;
+		return(highlight+offset);
 }
 
 /*
 *
-*       NAME		void CreatePath(char *filename)
+*       NAME		void ParseFileType(char *string,int currentFile)
 *
-*       FUNCTION	Creates directory path for display
-*					on screen
+*       FUNCTION	Used to hook in viewers, currently only TIM 
+*					viewer is supported
 *
 *       NOTES		
 *
@@ -688,43 +677,803 @@ void displayFileDetails(int file)
 *       20/03/98	Mike Kav        Created
 *
 */
-void CreatePath(char *filename)
+void ParseFileType(int currentFile, u_char ftype)
 {
-	char *nameptr = currentPath;
-
-	if( strcmp(filename,".") == 0 )
-		return;
-
-	if( strcmp(filename,"..") == 0 )
+	int* fdir;
+	u_char oldtype = 0;
+	u_char dtype;
+	EXTENDEDFILEDETAILS file;
+	VFSFILE* vf;
+	char* LongPath = 0;
+	CdlLOC* tracks;
+	XASECTOR* speedBuf;
+	u_char speed;
+	CdlLOC fp = {0,0,0,0};
+	u_char* textBuf = 0;
+	u_char *pimp, *loser, *psf, *winner;
+	//int lastDir1, lastDirLength2;
+	int i, j;
+	
+	//printf("LastDirLevel:%i Type:%X\n", lastDirLevel, lastDirType1[lastDirLevel]);
+	if (fullNames)
 	{
-		nameptr += (strlen(currentPath)-1);
-
-		while(*nameptr != '\\')
+		LongPath = fullNames[currentFile].name;
+		//printf("fullnames: %p path: %p\n", fullNames, LongPath);
+	}
+	
+	if (ftype == 0)
+	{
+		ftype = fileDetails[currentFile].type;
+	}
+	
+	if (ftype == MENU_LASTDIR)
+	{
+		if (lastDirLevel > 0)
 		{
-			*nameptr='\0';
-			nameptr--;
+			lastDirLevel--;
 		}
-		
-		if( strcmp(currentPath,"\\") != 0 )
-			*nameptr='\0';
+		oldtype = ftype;
+		ftype = lastDirType1[lastDirLevel];
 	}
-	else
+	
+	speed = TypeSpeed(ftype);
+
+	switch(ftype)
 	{
-		if(strlen(currentPath) != 1)
-			strcpy( (currentPath + strlen(currentPath)) ,"\\");
-		strcpy( (currentPath + strlen(currentPath)),filename);
+		case MUSIC_EXE:
+		case MUSIC_NEWEXE:
+		case MUSIC_ZEROEXE:
+		case MUSIC_CNF:
+		case MUSIC_VAG:
+		case MUSIC_XM:
+		case MUSIC_MOD:
+		case MUSIC_STR:
+		case MUSIC_STR1X:
+		case MUSIC_STR2X:
+		case MUSIC_NEWSEQ:
+		case MUSIC_DA:
+		case MUSIC_XA:
+		case MUSIC_XA1X:
+		case MUSIC_XA2X:
+			//printf("Loading Music\n");
+			PlayMusic(fileDetails[currentFile], ftype, LongPath);
+			break;
+			//InitStream(currentFile, 0x7F);
+			//InitStream(currentFile, 0);
+			//InitStream(currentFile, CdlModeSpeed);
+		case MUSIC_TIM:
+			CdStopMusic(MusicType);
+			FindFileDetails(&fileDetails[currentFile], LongPath);
+			TimViewer(fileDetails[currentFile]);
+			break;
+		case MENU_DIR:
+			CdStopMusic(MusicType);
+			FindFileDetails(&file, LongPath);
+			highlight = 0;
+			offset = 0;
+			title = default_title;
+			if (fullNames)
+			{
+				free3(fullNames);
+				fullNames = 0;
+			}
+			lastDirLevel = 0;
+			lastDir1[0] = fileDetails[currentFile].pos;
+			lastDirLength1[0] = fileDetails[currentFile].size;
+			lastDirType1[0] = MENU_DIR;
+			
+			lastDir			= fileDetails[currentFile].pos;
+			lastDirLength	= (fileDetails[currentFile].size / 2048);
+			if (oldtype != MENU_LASTDIR)
+			{
+				if (fullNames)
+				{
+					strcpy(currentPath, strchr(fullNames[currentFile].name, '\\'));
+				}
+				else
+				{
+					CreatePath(fileDetails[currentFile].name);
+				}
+			}
+			numFiles = GetNumDirEntries(lastDir,lastDirLength);
+			free3(fileDetails);
+			if (!currentPath[1])
+			{
+				numFiles++;
+			}
+			fileDetails = calloc3(numFiles, sizeof(EXTENDEDFILEDETAILS));
+			if (!currentPath[1])
+			{
+				fileDetails[numFiles-1].type = MENU_DA;
+				strcpy(fileDetails[numFiles-1].name, "*CD Audio Tracks");
+			}
+			GetDirDetails(lastDir,lastDirLength);
+			//lastDirLength = lastDirLength1[0];
+			break;
+		case MENU_VFS:
+		case MENU_VFSBYTE:
+		case MENU_VFSSECTOR:
+			CdStopMusic(MusicType);
+			highlight = 0;
+			offset = 0;
+			title = default_title;
+			//lastDir			= fileDetails[0].pos;
+			//lastDirLength	= fileDetails[0].size;
+			if (oldtype != MENU_LASTDIR)
+			{
+				PushVFS(currentFile, ftype);
+			}
+			file = fileDetails[currentFile];
+			free3(fileDetails); //has to be up here or it causes issues
+			
+			if (fullNames)
+			{
+				free3(fullNames);
+				fullNames = 0;
+			}
+			fdir = malloc3(2048);
+			FindFileDetails(&file, LongPath);
+			file.size = 2048;
+			LoadCdFile(file, (u_long*)fdir);
+			//printf("loaded sector 1\n");
+			numFiles = fdir[1];
+			//lastDir = file.pos;
+			if (ftype == MENU_VFSBYTE)
+			{
+				file.size = numFiles * sizeof(VFSFILE);
+			}
+			else
+			{
+				file.size = fdir[2] << 11;
+			}
+			if (file.size > 2048)
+			{
+				if (p.realloc)
+				{
+					fdir = realloc3(fdir, Sectors(file.size) << 11); //this doesnt have any other references so its fine
+					file.size -= 2048;
+					file.pos++;
+					LoadCdFile(file, (u_long*)(fdir + 512));
+					file.pos--;
+				}
+				else
+				{
+					free3(fdir);
+					fdir = malloc3(Sectors(file.size) << 11);
+					LoadCdFile(file, (u_long*)fdir);
+				}
+			}
+			vf = (VFSFILE*)(fdir + 3);
+			if (p.force < 5)
+			{
+				for (i = 0; i < fdir[1]; i++)
+				{
+					oldtype = GetMenuType(vf[i].stack, ftype);
+					if (oldtype == MENU_CANT_SELECT || oldtype == MENU_PROGRAM_TITLE)
+					{
+						//printf("FAILED FILE %s: %X\n", vf[i].name, vf[i].stack);
+						numFiles--;
+					}
+				}
+			}
+			numFiles += 2;
+			fileDetails = calloc3(numFiles, sizeof(EXTENDEDFILEDETAILS));
+			
+			CreateSpecialDirs();
+			j = 2;
+			for (i = 0; i < fdir[1]; i++)
+			{
+				//printf("Name %i: %s size: %i addr in file: %i\n", i, vf[i].name, vf[i].size, vf[i].addr);
+				
+				dtype = GetMenuType(vf[i].stack, ftype);
+				dtype = SetCustomTitle(vf[i].name, dtype, 64);
+				
+				//printf("file:%s type:%d\n", vf[i].name, dtype);
+				if (dtype != MENU_CANT_SELECT || p.force >= 5)
+				{
+					if (ftype == MENU_VFSSECTOR)
+					{
+						fileDetails[j].size = vf[i].sector_size << 11;
+					}
+					else
+					{
+						fileDetails[j].size = vf[i].size;
+					}
+					if (ftype == MENU_VFSBYTE)
+					{
+						fileDetails[j].pos = (vf[i].byte_addr >> 11) + file.pos;
+					}
+					else
+					{
+						fileDetails[j].pos = vf[i].addr + file.pos;
+					}
+					fileDetails[j].basepos = GetBasePos(vf[i].stack, vf[i].name, ftype, file.pos, vf);
+					fileDetails[j].basesize = GetBaseSize(vf[i].stack, ftype, vf);
+					fileDetails[j].type = dtype;
+					strncpy(fileDetails[j].name, vf[i].name, 64); //memcpy
+					fileDetails[j].name[63] = 0;
+					j++;
+				}
+				/*else if (p.force >= 3)
+				{
+					numFiles--;
+				}*/
+			}
+			vf = 0;
+			free3(fdir);
+			break;
+		case MENU_DA:
+			CdStopMusic(MusicType);
+			highlight = 0;
+			offset = 0;
+			title = default_title;
+			//lastDir			= fileDetails[0].pos;
+			//lastDirLength	= fileDetails[0].size;
+			if (oldtype != MENU_LASTDIR)
+			{
+				PushVFS(currentFile, ftype);
+			}
+			file = fileDetails[currentFile];
+			free3(fileDetails); //has to be up here or it causes issues
+			
+			if (fullNames)
+			{
+				free3(fullNames);
+				fullNames = 0;
+			}
+			tracks = malloc3(sizeof(CdlLOC) * 100); //400
+			j = (CdGetDiskType() == CdlCdromFormat) ? 1 : 0;
+			//j = 0;
+			numFiles = CdGetToc(tracks) + 2 - j;
+			fileDetails = calloc3(numFiles, sizeof(EXTENDEDFILEDETAILS));
+			CreateSpecialDirs();
+			
+			for (i = j; i < numFiles - 2; i++)
+			{
+				fileDetails[i+2-j].type = MUSIC_DA;
+				fileDetails[i+2-j].basepos = i + 1;
+				fileDetails[i+2-j].pos = CdPosToInt(&tracks[i+1]);
+				//printf("i+2-j:%i pos:%i i:%i j:%i\n", i+2-j, fileDetails[i+1-j].pos, i, j);
+				if (i > j)
+				{
+					fileDetails[i+1-j].size = (fileDetails[i+2-j].pos - fileDetails[i+1-j].pos) << 11; //CdPosToInt(&tracks[i])
+				}
+				sprintf(fileDetails[i+2-j].name, "CD audio track %i", i + 1);// - j);
+			}
+			free3(tracks);
+			break;
+		case MENU_XA:
+		case MENU_XA1X:
+		case MENU_XA2X:
+			speedBuf = malloc3(sizeof(XASECTOR) << 5); //32 to detect all tracks in case there's different bitrates of tracks
+			CdStopMusic(MusicType);
+			highlight = 0;
+			offset = 0;
+			title = default_title;
+			if (oldtype != MENU_LASTDIR)
+			{
+				PushVFS(currentFile, ftype);
+			}
+			file = fileDetails[currentFile];
+			FindFileDetails(&file, LongPath);
+			CdIntToPos(file.pos, &fp); //malloc3 interferes with this
+			free3(fileDetails); //has to be up here or it causes issues
+			if (fullNames)
+			{
+				free3(fullNames);
+				fullNames = 0;
+			}
+			//speedBuf = malloc3(sizeof(XASECTOR) * 8);
+			if (speed == 0x7f)
+			{
+				speed = XASpeed(fp, speedBuf, 32, 0xFF, 0xFF, 0, 0, 0, 32, 0);
+			}
+			else
+			{
+				XASpeed(fp, speedBuf, 32, 0xFF, 0xFF, 0, 0, 0, 32, 0);
+			}
+			if (!(speed == 0 || speed == CdlModeSpeed)) {
+				//printf("XASPEED FAILED!\n");
+				speed = 0x7f;
+			}
+			numFiles = 2;
+			for (i = 0; i < 32; i++)
+			{
+				if (XAChannels & 1 << i)
+				{
+					numFiles++;
+				}
+			}
+			switch (speed)
+			{
+				case 0:
+					dtype = MUSIC_XA1X;
+					break;
+				case CdlModeSpeed:
+					dtype = MUSIC_XA2X;
+					break;
+				default:
+					dtype = MUSIC_XA;
+					break;
+			}
+			fileDetails = calloc3(numFiles, sizeof(EXTENDEDFILEDETAILS));
+			CreateSpecialDirs();
+			XASpeed(fp, speedBuf, 32, dtype, 0xFF, fileDetails, numFiles, file.size, 32, 1);
+			free3(speedBuf);
+			break;
+		case MENU_TXT:
+			CdStopMusic(MusicType);
+			file = fileDetails[currentFile];
+			FindFileDetails(&file, LongPath);
+			textBuf = malloc3((Sectors(file.size) << 11) + 1);
+			LoadCdFile(file, (u_long*)textBuf);
+			textBuf[Sectors(file.size) << 11] = 0;
+			pimp = strchr(textBuf, '[');
+			loser = strstr(textBuf, "START"); //strchr_jis('S')
+			psf = strchr(textBuf, '"');
+			if (!pimp)
+			{
+				pimp = textBuf + strlen(textBuf);
+			}
+			if (!loser)
+			{
+				loser = textBuf + strlen(textBuf);
+			}
+			if (!psf)
+			{
+				psf = textBuf + strlen(textBuf);
+			}
+			if (pimp < loser)
+			{
+				winner = pimp;
+				ftype = MENU_TXTPIMP;
+			}
+			else
+			{
+				winner = loser;
+				ftype = MENU_TXTLOSER;
+			}
+			if (winner < psf)
+			{
+				if (!winner)
+				{
+					winner = psf;
+					ftype = MENU_TXTPSF;
+				}
+			}
+			else
+			{
+				winner = psf;
+				ftype = MENU_TXTPSF;
+			}
+			//printf("PSF: %p LOSER: %p PIMP: %p\n", psf, loser, pimp);
+			//printf("type:%X, pimp:%i, loser:%i, psf:%i, len:%i\n", ftype, pimp - textBuf, loser - textBuf, psf - textBuf, strlen(textBuf));
+		case MENU_TXTPIMP:
+		case MENU_TXTLOSER:
+		case MENU_TXTPSF:
+			if (!textBuf)
+			{
+				CdStopMusic(MusicType);
+				file = fileDetails[currentFile];
+				FindFileDetails(&file, LongPath);
+				textBuf = malloc3((Sectors(file.size) << 11) + 1);
+				LoadCdFile(file, (u_long*)textBuf);
+				textBuf[Sectors(file.size) << 11] = 0;
+			}
+			highlight = 0;
+			offset = 0;
+			title = default_title;
+			if (oldtype != MENU_LASTDIR)
+			{
+				PushVFS(currentFile, ftype);
+			}
+			file = fileDetails[currentFile];
+			free3(fileDetails); //has to be up here or it causes issues
+			
+			if (fullNames)
+			{
+				free3(fullNames);
+				fullNames = 0;
+			}
+			switch (ftype)
+			{
+				case MENU_TXTPSF:
+					numFiles = LoadPsf(textBuf, 0, 0, -1) + 2;
+					break;
+				case MENU_TXTLOSER:
+					numFiles = LoadLoser(textBuf, 0, 0, -1) + 2;
+					break;
+				case MENU_TXTPIMP:
+					numFiles = LoadPimp(textBuf, 0, 0, -1) + 2;
+					break;
+			}
+			fileDetails = calloc3(numFiles, sizeof(EXTENDEDFILEDETAILS));
+			fullNames = calloc3(numFiles, sizeof(FULLFILENAME));
+			switch (ftype)
+			{
+				case MENU_TXTPSF:
+					LoadPsf(textBuf, fileDetails + 2, fullNames + 2, numFiles - 2);
+					break;
+				case MENU_TXTLOSER:
+					LoadLoser(textBuf, fileDetails + 2, fullNames + 2, numFiles - 2);
+					break;
+				case MENU_TXTPIMP:
+					LoadPimp(textBuf, fileDetails + 2, fullNames + 2, numFiles - 2);
+					break;
+			}
+			CreateSpecialDirs();
+			free3(textBuf);
+			break;
+		default:
+			break;
 	}
-		
+
+	return;
+}
+
+int LoadPimp(u_char* buf, EXTENDEDFILEDETAILS* menu, FULLFILENAME* names, int max) //u_char* end, u_char newpimp
+{
+	int i = 0;
+	buf = strchr(buf, '[');
+	while (buf&& i != max)
+	{
+		if (menu&& i != max)
+		{
+			strncpy(menu[i].name, buf + 1, 64);
+			menu[i].name[63] = 0;
+			menu[i].type = MUSIC_STR;
+			sprintf(names[i].name, "cdrom:\\%i.STR;1", i);
+			//FindFileDetails(menu + i, names + i);
+		}
+		//printf("%i %s\n", i, buf);
+		i++;
+		buf = strchr(buf + strlen(buf) + 1, '[');
+	}
+	return i;
+}
+
+int LoadLoser(u_char* buf, EXTENDEDFILEDETAILS* menu, FULLFILENAME* names, int max)
+{
+	int i = 0;
+	u_char* buf2;
+	buf = strchr(buf, '"');
+	while (buf && i != max)
+	{
+		if (!strncmp(buf, "\"END\"", 5))
+		{
+			return i;
+		}
+		buf2 = strchr(buf + 1, '"');
+		if (!buf2)
+		{
+			return i;
+		}
+		if (menu)
+		{
+			strncpy(menu[i].name, buf + 1, constrain((buf2 - buf) - 1, 0, 64));
+			menu[i].name[63] = 0;
+			//printf("%i: %s", i, menu[i].name);
+			menu[i].type = MUSIC_NEWEXE;
+		}
+		buf = buf2 + 1;
+		buf2 = strchr(buf, '"');
+		if (!buf2)
+		{
+			return i;
+		}
+		if (names)
+		{
+			strncpy(names[i].name, buf, constrain((buf2 - buf), 0, 96));
+			names[i].name[95] = 0;
+			//printf(" - %s\n", names[i].name);
+		}
+		buf = strchr(buf2 + 1, '"');
+		if (!buf)
+		{
+			return i;
+		}
+		i++;
+	}
+	return i;
+}
+
+int LoadPsf(u_char* buf, EXTENDEDFILEDETAILS* menu, FULLFILENAME* names, int max)
+{
+	int i = 0;
+	u_char* buf2;
+	u_char dtype;
+	u_long fstack;
+	//FULLFILENAME tempname;
+	*(strchr(buf, 0x80)) = 0;
+	buf = strchr(buf, '"');
+	while (buf && i != max)
+	{
+		buf2 = strchr(buf + 1, '"');
+		if (!buf2)
+		{
+			return i;
+		}
+		if (menu)
+		{
+			strncpy(menu[i].name, buf + 1, constrain((buf2 - buf) - 1, 0, 64));
+			menu[i].name[63] = 0;
+		}
+		buf = strchr(buf2 + 1, '"');
+		buf2 = strchr(buf + 1, '"');
+		if (!buf || !buf2)
+		{
+			return i;
+		}
+		if (names)
+		{
+			*buf2 = 0;
+			sprintf(names[i].name, "cdrom:%s;1", buf + 1);
+			*buf2 = '"';
+		}
+		buf = strchr(buf2 + 1, '"');
+		buf2 = strchr(buf + 1, '"');
+		if (!buf || !buf2)
+		{
+			return i;
+		}
+		fstack = strtoul(buf + 1, 0, 16);
+		dtype = GetMenuType(fstack, MENU_TXTPSF);
+		if (menu)
+		{
+			dtype = SetCustomTitle(menu[i].name, dtype, 64);
+			menu[i].type = dtype;
+			menu[i].basepos = GetBasePos(fstack, strchr(names[i].name, ':') + 1, MENU_TXTPSF, 0, 0);
+			menu[i].basesize = GetBaseSize(fstack, MENU_TXTPSF, 0);
+			//printf("stack:%X %s\n", fstack, strchr(names[i].name, ':') + 1);
+		}
+		buf = strchr(buf2 + 1, '"');
+		switch (dtype)
+		{
+			case MENU_CANT_SELECT:
+			case MENU_PROGRAM_TITLE:
+				break;
+			case MENU_DIR:
+				names[i].name[strlen(names[i].name)-2] = 0;
+			default:
+				i++;
+				break;
+		}
+	}
+	return i;
+}
+
+/* //Not used since " won't be in an sjis char
+u_char* strchr_jis(u_char* s, u_char c, char sjis)
+{
+	u_char* s2 = 0;
+	if (!sjis)
+	{
+		return strchr(s, c);
+	}
+	while (!s2)
+	{
+		s2 = strchr(s, c);
+		if (!s2)
+		{
+			return 0;
+		}
+		switch (s2[-1])
+		{
+			case 0x81 ... 0x9F:
+			case 0xE0 ... 0xEF:
+				s = s2 + 1;
+				s2 = 0;
+				break;
+			default:
+				return s2;
+		}
+	}
+	return 0;
+}
+*/
+
+int PushVFS(int currentFile, u_char type)
+{
+	if (lastDirLevel < 63)
+	{
+		lastDirLevel++;
+		lastDir1[lastDirLevel] = fileDetails[currentFile].pos;
+		lastDirLength1[lastDirLevel] = fileDetails[currentFile].size;
+		lastDirType1[lastDirLevel] = type; //fileDetails[currentFile].type;
+		return 0;
+	}
+	return 1;
+}
+
+void CreateSpecialDirs()
+{
+	//fileDetails[0].filename[0] = '.';
+	fileDetails[0].name[0] = '.'; //[1]? u_short?
+	fileDetails[0].type = lastDirType1[0];
+	fileDetails[0].pos = lastDir1[0];
+	fileDetails[0].size = lastDirLength1[0];
+	
+	//strcpy(fileDetails[1].filename, "..");
+	strcpy(fileDetails[1].name, ".."); //[0][1][2]? u_long?
+	fileDetails[1].type = MENU_LASTDIR;
+	fileDetails[1].pos = lastDir1[lastDirLevel-1];
+	fileDetails[1].size = lastDirLength1[lastDirLevel-1];
+	
 	return;
 }
 
+u_char SetCustomTitle(char* name, u_char type, short maxlen)
+{
+	if (maxlen > 64)
+	{
+		maxlen = 64;
+	}
+	if (type == MENU_PROGRAM_TITLE)
+	{
+		//printf("%s\n", name);
+		strncpy(custom_title, name, maxlen);
+		custom_title[63] = 0;
+		title = custom_title;
+		return MENU_CANT_SELECT;
+	}
+	return type;
+}
+
+u_char GetMenuType(u_long type, u_char mtype)
+{
+	u_char ftype = type - 0xFFFFFF00;
+	switch (type)
+	{
+		case 0x00FFFD00 ... 0x00FFFDFF:
+			return MUSIC_XA1X;
+		case 0x00FFFE00 ... 0x00FFFEFF:
+			return MUSIC_XA2X;
+		case 0x00FFFF00 ... 0x00FFFFFF: //XA
+			return MUSIC_XA;
+		case 0x01000000 ... 0x0101FFFF:
+		//case 0x01010000 ... 0x0101FFFF:
+			return MENU_CANT_SELECT;
+		case 0xFFFFFF00 ... 0xFFFFFFFF:
+			if ((mtype == MENU_VFS || mtype == MENU_VFSBYTE || mtype == MENU_VFSSECTOR) &&
+			(ftype == MUSIC_EXE || ftype == MUSIC_NEWEXE || ftype == MUSIC_ZEROEXE))
+			{
+				return MENU_CANT_SELECT;
+			}
+			else if (ftype == MUSIC_SEQ || ftype == MUSIC_SEP || //ftype == MENU_PROGRAM_TITLE || //ftype == MUSIC_VAG ||
+			ftype == MUSIC_NEWSEQ || ftype == MUSIC_SEQONLY || ftype == MUSIC_VAB)
+			{
+				return MENU_CANT_SELECT;
+			}
+			return ftype; 
+		case 0x01020000 ... 0x0102FFFF:
+			if (mtype == MENU_VFS)
+			{
+				return MUSIC_NEWSEQ;
+			}
+			else
+			{
+				return MENU_CANT_SELECT;
+			}
+		default:
+			if (mtype == MENU_VFS || mtype == MENU_VFSBYTE || mtype == MENU_VFSSECTOR)
+			{
+				return MENU_CANT_SELECT;
+			}
+			else
+			{
+				return MUSIC_ZEROEXE;
+			}
+	}
+	return MENU_CANT_SELECT;
+}
+
+int GetBasePos(u_long type, char* filename, u_char mtype, int pos, VFSFILE* vf)
+{
+	switch (type)
+	{
+		case 0xFFFFFF00 + MUSIC_DA:
+			return strtol(filename, 0, 16);
+		case 0xFFFFFF00 + MUSIC_XA:
+			return 0xFF;
+		case 0x00FFFD00 ... 0x00FFFFFF: //XA
+			return (int)(type & 0xFF); //(type - 0x00FFFF00)
+		case 0x01020000 ... 0x0102FFFF:
+			switch (mtype)
+			{
+				case MENU_VFS:
+				case MENU_VFSSECTOR:
+					return (int)vf[type - 0x01020000].addr + pos;
+				case MENU_VFSBYTE:
+					return (int)(vf[type - 0x01020000].byte_addr >> 11) + pos;
+				default:
+					return 0;
+			}
+		/*
+		case 0x01000000 ... 0x0100FFFF:
+			return (int)(type - 0x01000000);
+		case 0x01010000 ... 0x0101FFFF:
+			return (int)(type - 0x01010000);
+		*/
+	}
+	return (int)type;
+}
+
+int GetBaseSize(u_long type, u_char mtype, VFSFILE* vf)
+{
+	switch (type)
+	{
+		case 0xFFFFFF00 + MUSIC_XA:
+		case 0x00FFFD00 ... 0x00FFFFFF:
+			return 1; //0xFF;
+		case 0x01020000 ... 0x0102FFFF:
+			switch (mtype)
+			{
+				case MENU_VFS:
+				case MENU_VFSBYTE:
+					return (int)vf[type - 0x01020000].size;
+				case MENU_VFSSECTOR:
+					return (int)(vf[type - 0x01020000].sector_size << 11);
+				default:
+					return 0;
+			}
+	}
+	return 0;
+}
+
+u_char GetFileType(char* string) 
+{
+	u_long extString = 0;
+	strncpy((u_char*)&extString,(string+strlen(string)-2),2);
+	if(extString != 0x313B) //strcmp(endString,";1") != 0
+	{
+		return MENU_DIR;
+	}
+	extString = 0;
+	strncpy((u_char*)&extString,(string+strlen(string)-5),3);
+	switch(extString)
+	{
+		case 0x525453:
+			return MUSIC_STR;
+		case 0x4D4954:
+			return MUSIC_TIM;
+		case 0x315342:
+			return MUSIC_STR1X;
+		case 0x325342:
+			return MUSIC_STR2X;
+		case 0x4D5850:
+			return MUSIC_XM;
+		case 0x544948:
+			return MUSIC_MOD;
+		case 0x455845:
+		case 0x585350:
+			return MUSIC_NEWEXE;
+		case 0x534656:
+			return MENU_VFS;
+		case 0x464E43:
+			return MUSIC_CNF;
+		case 0x41442E:
+		case 0x4D4350:
+		case 0x564157:
+			return MUSIC_DA;
+		case 0x41582E:
+			return MENU_XA;
+		case 0x314158:
+			return MENU_XA1X;
+		case 0x324158:
+			return MENU_XA2X;
+		case 0x545854:
+			return MENU_TXT;
+	}
+	//printf("extn: %s hex: %X\n", (u_char*)&extString, extString);
+
+	return MENU_CANT_SELECT;
+}
+
 /*
 *
-*       NAME		int InitCDBrowser(void)
+*       NAME		void displayFileDetails(int file)
 *
-*       FUNCTION	Initialises the CD Browser by loading up
-*					the root directory details and setting some
-*					variables
+*       FUNCTION	Display files name, size and position
 *
 *       NOTES		
 *
@@ -733,169 +1482,412 @@ void CreatePath(char *filename)
 *       20/03/98	Mike Kav        Created
 *
 */
-int InitCDBrowser(void)
+void displayFileDetails(int file)
 {
-	if(!CheckISO())
+	int fileNumber=0;
+	//char endString[3];
+	CdlLOC fp;
+	
+	int _offset = 0;
+	int _highlight = 0;
+	int forcetype;
+	int kanji;
+	
+	int slen = 10000;
+
+	CdIntToPos(fileDetails[file].pos,&fp);
+
+	SetBlock(32000);
+	kanji = KanjiFntOpen(18, 80, 600, 32, 960, 0, 960, 256, 0, 256);
+	if (fullNames)
 	{
-		return 0;
+		slen = strlen(fullNames[file].name);
 	}
+	while(!(Pressed(SQUARE_KEY) || Pressed(TRIANGLE_KEY)))
+	{
+		cdb ^= 1;
 
-	offset = 0;
-	highlight = 0;
+		fileNumber+=offset;
+				
+		//strncpy(endString,(fileDetails[file].filename+strlen(fileDetails[file].filename)-2),2);
+		//endString[2] = '\0';
+		if(fileDetails[file].type != MENU_DIR) //strcmp(endString,";1")==0 || lastDirLevel > 0
+		{
+			FntPrint("File Details - Press Triangle/Square to cancel\n\n");
+			if (slen < 60)
+			{
+				FntPrint("Filename = %s\n",fullNames[file].name);
+			}
+			else
+			{
+				FntPrint("File version = %s\n",fileDetails[file].version);
+			}
+		}
+		else
+		{
+			FntPrint("Directory Details - Press Triangle/Square to cancel\n\n");
+			if (slen < 50)
+			{
+				FntPrint("Directory name = %s\n",fullNames[file].name);
+			}
+			else
+			{
+				FntPrint("\n"); //"Directory name = %s\n",fileDetails[file].filename
+			}
+		}
+		
+		FntPrint("Size = %9d\t\t\t\t\t\t  Library Size = %d\n",fileDetails[file].size,fileDetails[file].basesize);
+		FntPrint("Absolute Position = %6d\t\t\t\tLibrary Position = %d\n",fileDetails[file].pos,fileDetails[file].basepos);
+		FntPrint("Position:\t\t\t\t\t\t\t\t Filetype = %d\n", fileDetails[file].type);
+		FntPrint("\tMin: %02x, Sec: %02x, Sector: %02x\n",fp.track,fp.minute,fp.second,fp.sector); //track doesn't work?
+		FntPrint("Full Name:\n\n\n\n\n");
+		KanjiFntPrint(kanji, "~p%s", fileDetails[file].name);
+		forcetype = drawTypeList(NUM_TYPES, _highlight, _offset); //need sizeof or something
+		if (p.displaytime && StreamPlaying != 2)
+		{
+			ShowTime(MusicType);
+		}
+		if (Pressed(UP_KEY))
+		{
+			MoveHighlight(-1, NUM_TYPES, &_highlight, &_offset);
+			//block = INPUT_DELAY;
+		}
+		else if (Pressed(DOWN_KEY))
+		{
+			MoveHighlight(1, NUM_TYPES, &_highlight, &_offset);
+			//block = INPUT_DELAY;
+		}
+		else if (Pressed(LEFT_KEY))
+		{
+			MoveHighlight(-10, NUM_TYPES, &_highlight, &_offset);
+			//block = INPUT_DELAY;
+		}
+		else if (Pressed(RIGHT_KEY))
+		{
+			MoveHighlight(10, NUM_TYPES, &_highlight, &_offset);
+			//block = INPUT_DELAY;
+		}
+		else if (Pressed(X_KEY))
+		{
+			// If the lid is up wait for the lid to shut, check disk
+			// and reload root directory
+			IsCdReady();
+			ParseFileType(file, menu_types[forcetype]);
+			ResetBlock(32000);
+			break;
+		}
+		else if (Pressed(CIRCLE_KEY))
+		{
+			PlayPauseMusic(MusicType);
+			ResetBlock(32000);
+		}
+		else if (Pressed(SELECT_KEY))
+		{
+			changeResMain(-1);
+		}
+		DrawSync(0);
+		FntFlush(-1);
+		KanjiFntFlush(kanji);
+		VSync(0);
 
-	IsCdReady();
-	// Initially get root dir details, use these to load in first directory
-	GetRootDirDetails(&startSec,&secLength);
+		PutDrawEnv(&db[cdb].draw);
+		PutDispEnv(&db[cdb].disp);
+	}
+	KanjiFntClose();
+	return;
+}
 
-	lastDir			= startSec;
-	lastDirLength	= secLength;
-	strcpy(currentPath,"\\");
+void PutEnvs()
+{
+	PutDrawEnv(&db[cdb].draw);
+	PutDispEnv(&db[cdb].disp);
+}
 
-	IsCdReady();
-	numFiles = GetNumDirEntries(startSec,secLength);
-	if(numFiles > MAXFILES)
+void MusicAdjust(short tempo, short tickmode)
+{
+	//if (highlight + offset > numFiles)
+	switch (fileDetails[highlight+offset].type)
 	{
-		printf("** Time to increase fileDetails structure\n");
+		case MUSIC_DA:
+		case MUSIC_XA:
+		case MUSIC_XA1X:
+		case MUSIC_XA2X:
+			if (tempo >= 1000)
+			{
+				fileDetails[highlight+offset].basesize = tempo - 1000; //FILE (1255 FOR NO FILE)
+			}
+			if (tickmode >= 100)
+			{
+				fileDetails[highlight+offset].basepos = tickmode - 100; //CHANNEL
+			}
+			if (tickmode == 99)
+			{
+				fileDetails[highlight+offset].basepos = tickmode = 0xFF; //NO CHANNEL
+			}
+			break;
 	}
+	
+}
 
-	IsCdReady();
-	GetDirDetails(startSec,secLength);
+void displayOSD()
+{
+	int OSDHighlight = 0, OSDOffset = 0;
+	u_char OSDType = 0;
+	SetBlock(32000);
+	while(!(Pressed(TRIANGLE_KEY) || Pressed(START_KEY)))
+	{
+		FntPrint("OSD Controls\n\n");
+		FntPrint("Pad Up/Down - Move 1\nPad Left/Right - Move 10\n");
+		FntPrint("L1/R1 - Value -/+ 1\nL2/R2 - Value -/+ 10\n");
+		FntPrint("Select - Change Resolution (Main Menu Only)\n");
+		FntPrint("X - Select option beginning with *\n");
+		FntPrint("Triangle/Start - Return\n\n");
+		cdb ^= 1;
+		OSDType = drawOSDList(OSDHighlight, OSDOffset);
+		//FntPrint("\n");
+		if (p.displaytime && StreamPlaying != 2)
+		{
+			ShowTime(MusicType);
+		}
+		if (Pressed(X_KEY))
+		{
+			OSDSelect(OSDType);
+		}
+		else if (Pressed(SELECT_KEY))
+		{
+			changeResMain(-1);
+		}
+		else if (Pressed(CIRCLE_KEY))
+		{
+			PlayPauseMusic(MusicType);
+			ResetBlock(32000);
+		}
+		else if (Pressed(UP_KEY))
+		{
+			MoveHighlightOSD(-1, &OSDHighlight, &OSDOffset);
+		}
+		else if (Pressed(DOWN_KEY))
+		{
+			MoveHighlightOSD(1, &OSDHighlight, &OSDOffset);
+		}
+		else if (Pressed(LEFT_KEY))
+		{
+			MoveHighlightOSD(-10, &OSDHighlight, &OSDOffset);
+		}
+		else if (Pressed(RIGHT_KEY))
+		{
+			MoveHighlightOSD(10, &OSDHighlight, &OSDOffset);
+		}
+		else if (Pressed(L1_KEY)) 
+		{
+			OSDIncDec(-1, OSDType);
+		}
+		else if (Pressed(L2_KEY)) 
+		{
+			OSDIncDec(-10, OSDType);
+		}
+		else if (Pressed(R1_KEY)) 
+		{
+			OSDIncDec(1, OSDType);
+		}
+		else if (Pressed(R2_KEY)) 
+		{
+			OSDIncDec(10, OSDType);
+		}
+		
+		
+		DrawSync(0);
+		FntFlush(-1);
+		VSync(0);
 
-	return 1;
+		PutDrawEnv(&db[cdb].draw);
+		PutDispEnv(&db[cdb].disp);
+	}
+	return;
 }
 
-
 /*
 *
-*       NAME		static short ExitPressed(void)
+*       NAME		void CreatePath(char *filename)
 *
-*       FUNCTION	Normally returns 0 until a button is
-*					pressed, used by the streaming code
-*					to stop playing a stream
+*       FUNCTION	Creates directory path for display
+*					on screen
 *
 *       NOTES		
 *
 *       CHANGED		PROGRAMMER      REASON
 *       -------		----------      ------
-*       23/03/98	Mike Kav        Created
+*       20/03/98	Mike Kav        Created
 *
 */
-static short ExitPressed(void) {
-	return (Pressed(X_KEY) || Pressed(SELECT_KEY));
+void CreatePath(char *filename)
+{
+	char *nameptr = currentPath;
+
+	if( strcmp(filename,".") == 0 )
+		return;
+
+	if( strcmp(filename,"..") == 0 )
+	{
+		nameptr += (strlen(currentPath)-1);
+
+		while(*nameptr != '\\')
+		{
+			*nameptr='\0';
+			nameptr--;
+		}
+		
+		if( strcmp(currentPath,"\\") != 0 )
+			*nameptr='\0';
+	}
+	else
+	{
+		if(strlen(currentPath) != 1)
+			strcpy( (currentPath + strlen(currentPath)) ,"\\");
+		strcpy( (currentPath + strlen(currentPath)),filename);
+	}
+		
+	return;
 }
 
 /*
 *
-*       NAME		void InitStream(int file)
+*       NAME		int InitCDBrowser(void)
 *
-*       FUNCTION	Gets video stream details and fills
-*					out a stream data structure to enable good
-*					old MOVIE2 to play the stream (note that the
-*					movie code is MOVIE2 with a couple of modifcations)
+*       FUNCTION	Initialises the CD Browser by loading up
+*					the root directory details and setting some
+*					variables
 *
 *       NOTES		
 *
 *       CHANGED		PROGRAMMER      REASON
 *       -------		----------      ------
-*       23/03/98	Mike Kav        Created
+*       20/03/98	Mike Kav        Created
 *
 */
-StrInfo streamFile;
-
-void InitStream(int file)
+int InitCDBrowser(void)
 {
-	u_char gbuffer[2340];	// CD data loaded to this buffer
-	u_long *cAddress = (u_long *)gbuffer;	// used to get buffer details
-	int result;				// CD read return value
-	CdlLOC fp = {0,0,0,0};				// CD file details
-
-	CdSectorHeader headerDetails;
-
-
-	CdIntToPos(fileDetails[file].pos,&fp);
+	//EXTENDEDFILEDETAILS ef = {0};
+	if(!CheckISO())
+	{
+		return 0;
+	}
 
-    while (!CdControlB(CdlSeekL,(unsigned char *)&fp, 0))
-    {
-      printf("CdlSeekL failed\n");
-    }
+	offset = 0;
+	highlight = 0;
+	IsCdReady();
 
-    if(!CdRead (1, (unsigned long *)gbuffer,(CdlModeSpeed|CdlModeRT|CdlModeSF|CdlModeSize1)))
-    {
-      printf("CdRead failed\n");
-      return;
-    }
+	// Initially get root dir details, use these to load in first directory
+	GetRootDirDetails(&startSec,&secLength);
 
-    // Block until the CD has finished reading
-    do
-    {
-		result = CdReadSync(1,0);
-		if (result < 0)       // error
+	lastDir			= startSec;
+	lastDirLength	= secLength;
+	strcpy(currentPath,"\\");
+	lastDirLevel = 0;
+	lastDirType1[0] = MENU_DIR;
+	lastDir1[0] = lastDir;
+	lastDirLength1[0] = secLength << 11;
+	
+	if (autorun)
+	{
+		IsCdReady();
+		numFiles = 1;
+		fileDetails = calloc3(numFiles, sizeof(EXTENDEDFILEDETAILS));
+		fullNames = calloc3(numFiles, sizeof(FULLFILENAME));
+		//printf("autorun is %i\n", autorun);
+		if (autorun & 0x2) // 1 << 1
 		{
-        	return;
+			if (FindFileDetails(&fileDetails[0], "cdrom:\\SYSTEM.CNF;1"))
+			{
+				//printf("Found system.cnf\n");
+				ParseFileType(0, MUSIC_CNF);
+				autorun = 0;
+			}
 		}
-	}while (result != 0);
-
-	headerDetails.id=*(unsigned short*)(cAddress+3);
-	headerDetails.type=*( ((unsigned short*)(cAddress+3)+1) );
-
-	cAddress+=4;
-	headerDetails.secCount=*(unsigned short*)(cAddress);
-	headerDetails.nSectors=*( ((unsigned short*)(cAddress)+1) );
-
-	cAddress+=1;
-	headerDetails.frameCount=*(unsigned short *)(cAddress);
-	cAddress+=1;
-	headerDetails.frameSize=*(unsigned short *)(cAddress);
-
-	cAddress+=1;
-	headerDetails.width=*(unsigned short *)(cAddress);
-	headerDetails.height=*( ((unsigned short *)(cAddress)+1) );
-
-	cAddress+=3;
-	headerDetails.reserved=*(unsigned short *)(cAddress);
-
-	strcpy(streamFile.strName,fileDetails[file].filename);
-	streamFile.strPos = fp;
-	streamFile.mode = streamMode;
-	streamFile.drawBorders = borders;
-	streamFile.scrWidth = 320;
-	streamFile.x = 0;
-	streamFile.y = 0;
-	streamFile.width = headerDetails.width;
-	streamFile.height = headerDetails.height;
-	streamFile.endFrame = 40000;
-	streamFile.vlcBufSize = 0;
-	streamFile.volume = volume;
-
-
-        printf("Stream:%s\n",streamFile.strName);
-        printf("File Pos:");
-//        streamFile.strPos = fp;
-//        streamFile.mode = streamMode;
- //       streamFile.drawBorders = borders;
-//        streamFile.scrWidth = 320;
-//        streamFile.x = 0;
-//        streamFile.y = 0;
-
-        printf("Width:%d,Height:%d\n",streamFile.width,streamFile.height);
-//        streamFile.height = headerDetails.height;
-//        streamFile.endFrame = 40000;
-//        streamFile.vlcBufSize = 0;
-//        streamFile.volume = volume;
-
-
-	PlayStream(&streamFile, ExitPressed);
+		if (autorun & 0x2)
+		{
+			if (FindFileDetails(&fileDetails[0], "cdrom:\\PSX.EXE;1"))
+			{
+				//printf("Found psx.exe\n");
+				strcpy(fullNames[0].name, "cdrom:\\PSX.EXE;1");
+				ParseFileType(0, MUSIC_NEWEXE);
+				autorun = 0;
+			}
+		}
+		if (autorun & 0x1)
+		{
+			if (FindFileDetails(&fileDetails[0], "cdrom:\\AUTORUN.VFS;1"))
+			{
+				ParseFileType(0, MENU_VFS);
+				autorun = 0;
+			}
+		}
+		if (autorun & 0x1)
+		{
+			if (FindFileDetails(&fileDetails[0], "cdrom:\\MMENU.TXT;1"))
+			{
+				ParseFileType(0, MENU_TXTPSF);
+				autorun = 0;
+			}
+		}
+		if (autorun & 0x1)
+		{
+			if (FindFileDetails(&fileDetails[0], "cdrom:\\PSFMENU\\TITLES.TXT;1"))
+			{
+				ParseFileType(0, MENU_TXTPSF);
+				autorun = 0;
+			}
+		}
+		if (autorun & 0x1)
+		{
+			if (FindFileDetails(&fileDetails[0], "cdrom:\\PROGRAMS.TXT;1"))
+			{
+				ParseFileType(0, MENU_TXTLOSER);
+				autorun = 0;
+			}
+		}
+		if (autorun & 0x1)
+		{
+			if (FindFileDetails(&fileDetails[0], "cdrom:\\NAMES.TXT;1"))
+			{
+				ParseFileType(0, MENU_TXTPIMP);
+				autorun = 0;
+			}
+		}
+		//autorun = 0;
+		//numFiles = 0;
+		//free3(fileDetails);
+		//free3(fullNames);
+		//fullNames = 0;
+	}
+	else
+	{
+	IsCdReady();
+	
+	numFiles = GetNumDirEntries(startSec,secLength) + 1;
 
-	return;
+	/*
+	if(numFiles > MAXFILES)
+	{
+		printf("** Time to increase fileDetails structure\n");
+	}
+	*/
+	fileDetails = calloc3(numFiles, sizeof(EXTENDEDFILEDETAILS));
+	fileDetails[numFiles-1].type = MENU_DA;
+	strcpy(fileDetails[numFiles-1].name, "*CD Audio Tracks");
+	IsCdReady();
+	GetDirDetails(startSec,secLength);
+	}
+	return 1;
 }
 
 InitPoly()
 {
 	// Load texture to VRAM
-	texture.addr=pictureTIM;
+	texture.addr=0;
 	if(!loadTIM(&texture))
 		return;
-
+ 
 	// Initialise poly
     SetPolyFT4(&poly);
     setRGB0(&poly, 100, 100, 100);
@@ -926,4 +1918,4 @@ InitPoly()
 		 texture.texture_w-1, texture.texture_h-1);
 		setXYWH(&poly, 255, 0, texture.texture_w, texture.texture_h);
     }
-}
+}
\ No newline at end of file
diff --git a/MAIN.H b/MAIN.H
index e18ca4d..1b19404 100644
--- a/MAIN.H
+++ b/MAIN.H
@@ -20,11 +20,10 @@
  */
 
 // Screen position and dimensions. 
-#define	FRAME_X			512
-
-#define	FRAME_Y			256
-#define SCREEN_X		0
-#define SCREEN_Y		18	
+extern short FRAME_X;
+extern short FRAME_Y;
+extern short SCREEN_X;
+extern short SCREEN_Y;
 
 /* ---------------------------------------------------------------------------
  * - DATA TYPE AND STRUCTURE DECLARATIONS
@@ -61,16 +60,31 @@ extern unsigned long __textlen;
 extern unsigned long _ramsize;
 extern unsigned long _stacksize;
 
+//imports and globals
+extern u_char MusicType, StreamPlaying;
+
+//extern u_long vsyncCount;
+
 // Function prototypes
-static void		InitSys(void); 
-static void		CloseSys(void);
-static void		VSyncCB(void);
-static void		ClearVRAM(void);
+//static void		InitSys(void); //warning
+//static void		CloseSys(void); //warning
+void			VSyncCB(void);
+//static void		ClearVRAM(void); //warning
 void			CreatePath(char *filename);
 void			InitEnvs(DB *db);
-void			SndInit(void);
-void			MoveHighlight(int i, int numFiles);
-void			ParseFileType(char *string,int currentFile);
+//void			SndInit(void);
+void			ParseFileType(int currentFile, u_char ftype);
 void			displayFileDetails(int file);
-void			InitStream(int file);
+//void			InitStream(int file, char speed);
+int drawTypeList(int numTypes, int highlight, int offset);
+
+u_char GetFileType(char *string);
+void displayOSD();
+u_char GetMenuType(u_long type, u_char mtype);
+int PushVFS(int currentFile, u_char type);
+void CreateSpecialDirs();
+void PutEnvs();
+u_char SetCustomTitle(char* name, u_char type, short maxlen);
+void MusicAdjust(short tempo, short tickmode);
+//u_char* strchr_jis(u_char* s, u_char c, char sjis);
 #endif // __MAIN_H 
diff --git a/MAIN.LNK b/MAIN.LNK
index f7cdd80..b685cb2 100644
--- a/MAIN.LNK
+++ b/MAIN.LNK
@@ -19,11 +19,12 @@ bss     group   bss                     ; main data group
 	inclib  "c:\psx\lib\libcd.lib"
         inclib  "c:\psx\lib\libds.lib"
 	inclib  "c:\psx\lib\libpress.lib"
-	inclib  "c:\psx\lib\libc.lib"
+	inclib  "c:\psx\lib\libc2.lib"
 	inclib  "c:\psx\lib\libspu.lib"
 	inclib  "c:\psx\lib\libsnd.lib"
         inclib  "c:\psx\lib\libgs.lib"
-
+	inclib "c:\psx\lib\xmplay.lib"
+	
 ; Use libsn.lib for development and None2.lib for child.
 	inclib  "c:\psx\lib\libsn.lib"
 
@@ -32,7 +33,10 @@ bss     group   bss                     ; main data group
         include control.obj
         include timview.obj
         include movie.obj
-        include datafile.obj
+		include music.obj
+		include hitmod.obj
+		
+        ;include datafile.obj
 
 	regs    pc=__SN_ENTRY_POINT     ; entry point
 
diff --git a/MOVIE.C b/MOVIE.C
index 4c006be..6d58d69 100644
--- a/MOVIE.C
+++ b/MOVIE.C
@@ -29,9 +29,15 @@
 #include <libspu.h>
 #include <libpress.h>
 #include <libsnd.h>
+#include <malloc.h>
 
+#include <xmplay.h>
 #include "movie.h"
 #include "sceecd.h"
+//#include "state.h"
+#include "control.h"
+#include "music.h"
+
 
 /* ---------------------------------------------------------------------------
  * - CONSTANTS
@@ -44,21 +50,6 @@
 // Define for extra debug info.
 #define DEBUG
 
-
-#ifdef NTSC
-
-#define	FRAME_Y			240
-#define SCREEN_X		0
-#define SCREEN_Y		0	
-
-#else
-
-#define	FRAME_Y			256
-#define SCREEN_X		0
-#define SCREEN_Y		18	
-
-#endif // NTSC
-
 // Maximum number of retries.
 #define MAX_RETRY				5
 
@@ -92,6 +83,9 @@
 // RunLevel header size in bytes.
 #define RL_HEADER_SIZE			1024
 
+//Number of frames X held before panic exit
+#define FORCE_EXIT_FRAMES		150
+
 /* ---------------------------------------------------------------------------
  * - DATA TYPE AND STRUCTURE DECLARATIONS
  * ---------------------------------------------------------------------------
@@ -124,18 +118,19 @@ typedef struct {
  * ---------------------------------------------------------------------------
  */
  
-#ifdef TESTING
+
 static int		t1, t2;							// Timers.
 
 static DRAWENV	draw[2];						// DrawEnvs for FntPrint.
-#endif
 
+u_char OSD_MENU_TYPE = 0;
+extern ParamsShared p;
+//extern const int OSDTYPES;
 
-#if defined(TESTING)||defined(FIND_VLCBUF)
 static short	firstFrame = 1,					// Frame skipping check.
 				numSkipped = 0,
 				prevFrameNum = 0;			
-#endif
+
 
 
 #ifdef FIND_VLCBUF
@@ -149,11 +144,16 @@ extern u_long	_ramsize;
 extern u_long	_stacksize;
 
 static DecEnv	dec;							// Streaming Env.
+static u_long	*ringBuf;
 
-static u_long	oldHeapbase;  					// Heapbase before PlayStream.
+// Heapbase before PlayStream.
 
 static SndVolume oldVolume;						// Old ADPCM volume.
 
+extern short SCREEN_X, SCREEN_Y, FRAME_X, FRAME_Y;
+
+//extern short volume; //TEMP, CHANGE TO CONTROL.C
+
 /* ---------------------------------------------------------------------------
  * - PRIVATE FUNCTION PROTOTYPES
  * ---------------------------------------------------------------------------
@@ -163,27 +163,30 @@ static void StrDecDCToutCB(void);
 static void StrInit(StrInfo *str);
 static void StrEnd(void);
 static void StrClearVRAM(void);
-static short StrKickCD(CdlLOC *loc);
+static short StrKickCD(CdlLOC *loc, char CDSPEED);
 static u_long *StrGetNextFrame(void);
-static void StrVLCFrame(u_long *frame);
+static short StrVLCFrame(u_long *frame);
 static void	StrDrawDecodeSync(void);
-static short StrFadeOutVol(short *fadeVol);
+//static short StrFadeOutVol(short *fadeVol);
 static long GetDCToutSize(void);
 static u_short ScalePPW(u_short n);
 static u_short GetDCT_MODE(void);
 
+//static int SectorsToVSyncs(int pos, int speed);
+//static int VSyncsToSectors(int pos, int speed);
+
 #ifdef FIND_VLCBUF
 static void PrintVLCBufSize(void); 
 #endif
 
-static u_long AllocMem(u_long size);
+//static u_long AllocMem(u_long size);
 
 /* ---------------------------------------------------------------------------
  * - FUNCTION DEFINITIONS
  * ---------------------------------------------------------------------------
  */
 
-short PlayStream(StrInfo *str, short (*keyHandler)(void)) {
+short PlayStream(StrInfo *str, int endSector, char speed) {
 
 
 /* - Type:	PUBLIC
@@ -204,16 +207,29 @@ short PlayStream(StrInfo *str, short (*keyHandler)(void)) {
 	short		frameRetry = 0;
 	short		strQuit = 0;
 	short		fadeVol = 0;
+	
+	int OSDHighlight = 0, OSDOffset = 0;
+	u_char OSDType = 0;
+	
+	//int FONTB;
 
 	fp.pos.minute	= str->strPos.minute;
 	fp.pos.second	= str->strPos.second;
 	fp.pos.sector	= str->strPos.sector;
 	fp.pos.track	= str->strPos.track;
 
+//FONTB = FntOpen(160, 160, 128, 3200, 1, 1024);
+
+	if (speed) {
+		p.endVSync = SectorsToVSyncs(endSector - CdPosToInt(&fp.pos), 2);
+	} else {
+		p.endVSync = SectorsToVSyncs(endSector - CdPosToInt(&fp.pos), 1);
+	}
+
 	StrInit(str);
 
 
-	if (!StrKickCD(&fp.pos)) {;
+	if (!StrKickCD(&fp.pos, speed)) {;
 #ifdef DEBUG
 		printf("ERROR: MOVIE -- Couldn't start the CD!!\n");
 #endif
@@ -223,7 +239,6 @@ short PlayStream(StrInfo *str, short (*keyHandler)(void)) {
 
 
 	while (!(frame = StrGetNextFrame())) {		// If we can't get frame exit!
-
 		if (++frameRetry == MAX_RETRY) {
 #ifdef DEBUG
 			printf("ERROR: MOVIE -- Couldn't get first frame!!\n");
@@ -236,25 +251,36 @@ short PlayStream(StrInfo *str, short (*keyHandler)(void)) {
 
 	frameRetry = 0;
 	StrVLCFrame(frame);
+	
+	if (p.pausestart)
+	{
+		PlayPauseMusic(MUSIC_STR);
+	}
 
-
-	while (!dec.rewindSwitch && !strQuit) {
-
-
+	while (!(dec.rewindSwitch == 1) && !strQuit) {
+		/*
+		if (RPressed(RIGHT_KEY) > FORCE_EXIT_FRAMES) {
+			printf("STR PANIC!\n");
+			StrEnd();
+			return PLAYSTR_USER;
+		}
+		*/
 		DecDCTin(dec.vlcBuffer[dec.vlcId], GetDCT_MODE());
 		DecDCTout(dec.imageBuffer[dec.imageId], GetDCToutSize());
 
 
-		if (!(frame = StrGetNextFrame())) {
 
-			if (++frameRetry == MAX_RETRY)
-				strQuit = PLAYSTR_ERROR;
-			
+		if (StreamPlaying && !(frame = StrGetNextFrame())) {
+
+			if (++frameRetry == MAX_RETRY) {
+				printf("ERROR: Failed to get frame, exiting!\n");
+				strQuit = PLAYSTR_USER;
+			}
+				
 		} else {
 			frameRetry = 0;
 		}
 
-
 #ifdef TESTING
 		t2 = VSync(1);					// Time VLC.
 		StrVLCFrame(frame);
@@ -264,27 +290,158 @@ short PlayStream(StrInfo *str, short (*keyHandler)(void)) {
 #endif
 
 
-		// Check for exit. 
-		if (!fadeVol && (*keyHandler)())
-			fadeVol = dec.volume;
+
+
+		//Menu Stuff Clean Up Fomat Later
+		if (StreamPlaying != 2) {
+			SetBlock();
+		}
+		
+
 
 
 		// Fade the volume down to zero. Then trigger exit.
 		if (fadeVol)
-			strQuit = StrFadeOutVol(&fadeVol);
+			strQuit = PLAYSTR_USER;//StrFadeOutVol(&fadeVol);
 
 
 		StrDrawDecodeSync();
 
 
-#ifdef TESTING
-		DrawSync(0);
-		FntPrint("\nVLC Time = %d\n", t2);
-		FntPrint("Total Time = %d\n", VSync(1) - t1);	// Timing.
-		FntFlush(-1);
-#endif
 
+		DrawSync(0);
 
+		
+		switch (OSD_MENU_TYPE)
+		{
+			case 2:
+				FntPrint("\nVLC Time = %d\n", t2);
+				FntPrint("VSyncs: %d ", VSync(-1) - p.vsyncBase);
+				FntPrint("Total Time = %d\n", VSync(1) - t1);	// Timing.
+				if (Pressed(TRIANGLE_KEY) || Pressed(SQUARE_KEY))
+				{
+					OSD_MENU_TYPE = 0;
+				}
+				if (Pressed(START_KEY)) {
+					OSD_MENU_TYPE = 1;
+				}
+				if (Pressed(L1_KEY)) {
+					dec.rewindSwitch = -1;
+					SeekMusic(MUSIC_STR, 0, -p.seekframes, CdPosToInt(&fp.pos), endSector, -p.seekseconds, -p.seekminutes, speed);
+					//p.vsyncPauseBase = 0; //VSync(-1);
+				}
+				if (Pressed(R2_KEY)) {
+					dec.rewindSwitch = -1;
+					SeekMusic(MUSIC_STR, 0, p.seekframes, CdPosToInt(&fp.pos), endSector, p.seekseconds, p.seekminutes, speed);
+					//p.vsyncPauseBase = 0; //VSync(-1);
+				}
+				if (BPressed(L1_KEY)) {
+					p.volume = SetVolume(p.volume - 1, MUSIC_STR);
+				}
+				if (BPressed(R1_KEY)) {
+					p.volume = SetVolume(p.volume + 1, MUSIC_STR);
+				}
+
+				if (Pressed(CIRCLE_KEY)) {
+					PlayPauseMusic(MUSIC_STR);
+					SetBlock();
+				}
+				break;
+			case 1:
+				ShowTime(MUSIC_STR);
+				OSDType = drawOSDList(OSDHighlight, OSDOffset);
+				if (Pressed(X_KEY))
+				{
+					if (OSDType == OSD_SETTIME)
+					{
+						dec.rewindSwitch = -1;
+					}
+					OSDSelect(OSDType);
+				}
+				if (Pressed(UP_KEY))
+				{
+					MoveHighlightOSD(-1, &OSDHighlight, &OSDOffset);
+				}
+				if (Pressed(DOWN_KEY))
+				{
+					MoveHighlightOSD(1, &OSDHighlight, &OSDOffset);
+				}
+				if (Pressed(LEFT_KEY))
+				{
+					MoveHighlightOSD(-10, &OSDHighlight, &OSDOffset);
+				}
+				if (Pressed(RIGHT_KEY))
+				{
+					MoveHighlightOSD(10, &OSDHighlight, &OSDOffset);
+				}
+				if (Pressed(TRIANGLE_KEY) || Pressed(START_KEY))
+				{
+					OSD_MENU_TYPE = 0;
+				}
+				if (Pressed(L1_KEY)) 
+				{
+					OSDIncDec(-1, OSDType);
+				}
+				if (Pressed(L2_KEY)) 
+				{
+					OSDIncDec(-10, OSDType);
+				}
+				if (Pressed(R1_KEY)) 
+				{
+					OSDIncDec(1, OSDType);
+				}
+				if (Pressed(R2_KEY)) 
+				{
+					OSDIncDec(10, OSDType);
+				}
+				if (Pressed(SQUARE_KEY)) {
+					OSD_MENU_TYPE = 2;
+				}
+				if (Pressed(CIRCLE_KEY)) {
+					PlayPauseMusic(MUSIC_STR);
+					SetBlock();
+				}
+				break;
+			case 0:
+				if (Pressed(L1_KEY)) {
+					dec.rewindSwitch = -1;
+					SeekMusic(MUSIC_STR, 0, -p.seekframes, CdPosToInt(&fp.pos), endSector, -p.seekseconds, -p.seekminutes, speed);
+					//p.vsyncPauseBase = 0; //VSync(-1);
+				}
+				if (Pressed(R2_KEY)) {
+					dec.rewindSwitch = -1;
+					SeekMusic(MUSIC_STR, 0, p.seekframes, CdPosToInt(&fp.pos), endSector, p.seekseconds, p.seekminutes, speed);
+					//p.vsyncPauseBase = 0; //VSync(-1);
+				}
+				if (BPressed(L1_KEY)) {
+					p.volume = SetVolume(p.volume - 1, MUSIC_STR);
+				}
+				if (BPressed(R1_KEY)) {
+					p.volume = SetVolume(p.volume + 1, MUSIC_STR);
+				}
+
+				if (Pressed(CIRCLE_KEY)) {
+					PlayPauseMusic(MUSIC_STR);
+					SetBlock();
+				}
+				
+				if (Pressed(START_KEY)) {
+					OSD_MENU_TYPE = 1;
+				}
+				if (Pressed(SELECT_KEY)) {
+					OSD_MENU_TYPE = 2;
+				}
+				
+				// Check for exit. 
+				if (Pressed(TRIANGLE_KEY))
+					fadeVol = dec.volume;
+				break;
+		}
+		
+		//FntPrint("FONTB\n", FONTB);
+		//FntFlush(FONTB);
+		
+		FntFlush(-1);
 		DrawSync(0);
 		VSync(0);
 
@@ -377,13 +534,14 @@ static void StrInit(StrInfo *str) {
 
 	short	x, y, w, h;
 	short	scrWidth;
-	u_long	*ringBuf;
+	
 	u_long	vlcBufSize,
 			imageBufSize;	
 
 
-	oldHeapbase = __heapbase;
-
+	//oldHeapbase = __heapbase;
+	p.vsyncBase = VSync(-1);
+	p.vsyncPauseBase = 0;
 
 	x = str->x;
 	y = str->y;	
@@ -401,8 +559,8 @@ static void StrInit(StrInfo *str) {
 	prevFrameNum = 0;			
 
 	// Init DrawEnvs for FntPrint.
-	SetDefDrawEnv(&draw[0], 0,   0,       scrWidth, FRAME_Y);
-	SetDefDrawEnv(&draw[1], 0,   FRAME_Y, scrWidth, FRAME_Y);
+	SetDefDrawEnv(&draw[0], 0,   0,       ScalePPW(scrWidth), FRAME_Y);
+	SetDefDrawEnv(&draw[1], 0,   FRAME_Y, ScalePPW(scrWidth), FRAME_Y);
 	setRGB0(&draw[0], 0, 0, 0);
 	setRGB0(&draw[1], 0, 0, 0);
 	draw[0].isbg = draw[1].isbg = 1;
@@ -429,7 +587,7 @@ static void StrInit(StrInfo *str) {
 	dec.vlcId = 0;
 	dec.imageId = 0;
 	
-
+//printf("ScrWidth:%i\n", scrWidth);
 	// Init the display environments.
 	SetDefDispEnv(&dec.disp[0], 0,   FRAME_Y, scrWidth, FRAME_Y);
 	SetDefDispEnv(&dec.disp[1], 0,   0,       scrWidth, FRAME_Y);
@@ -465,8 +623,8 @@ static void StrInit(StrInfo *str) {
 #endif // FIND_VLCBUF
 
 
-	dec.vlcBuffer[0] = (u_long *) AllocMem(vlcBufSize);
-	dec.vlcBuffer[1] = (u_long *) AllocMem(vlcBufSize);
+	dec.vlcBuffer[0] = malloc3(vlcBufSize);
+	dec.vlcBuffer[1] = malloc3(vlcBufSize);
 
 
 	if (dec.is24Bit)
@@ -474,15 +632,15 @@ static void StrInit(StrInfo *str) {
 	else
 		imageBufSize = SLICE_WIDTH * 2 * h;
 
-	dec.imageBuffer[0] = (u_long *) AllocMem(imageBufSize);
-	dec.imageBuffer[1] = (u_long *) AllocMem(imageBufSize); 
+	dec.imageBuffer[0] = malloc3(imageBufSize);
+	dec.imageBuffer[1] = malloc3(imageBufSize); 
 
 
 	// Init the MDEC.
 	DecDCTReset(0);
 	DecDCTvlcSize(0);
 	DecDCToutCallback((void (*)()) StrDecDCToutCB);
-	ringBuf = (u_long *) AllocMem(RING_SIZE * FORM1_SIZE);
+	ringBuf = malloc3(RING_SIZE * FORM1_SIZE);
 	StSetRing(ringBuf, RING_SIZE);
 
 
@@ -509,7 +667,12 @@ static void StrEnd(void) {
 	StUnSetRing();
 	CdControlB(CdlPause, 0, 0);
 	DecDCToutCallback(0);            
-	__heapbase = oldHeapbase;
+	//__heapbase = oldHeapbase;
+	free3(dec.vlcBuffer[0]);
+	free3(dec.vlcBuffer[1]);
+	free3(dec.imageBuffer[0]);
+	free3(dec.imageBuffer[1]);
+	free3(ringBuf);
 
 
 	if (dec.is24Bit)			// Clear VRAM to remove any 24bit graphics.
@@ -518,10 +681,10 @@ static void StrEnd(void) {
 
 	// Restore previous ADPCM volume. 
 	SsSetSerialVol(SS_SERIAL_A, oldVolume.left, oldVolume.right);
-
-
+	StreamPlaying = 2;
+	p.vsyncPauseBase = VSync(-1);
 #ifdef DEBUG
-	printf("FrameCount %d\n", dec.frameCount);
+	printf("FrameCount %d, VSyncs %d\n", dec.frameCount, VSync(-1) - p.vsyncBase);
 #endif
 }
 
@@ -548,7 +711,7 @@ static void StrClearVRAM(void) {
 
 /* ------------------------------------------------------------------------ */
 
-static short StrKickCD(CdlLOC *loc) {
+static short StrKickCD(CdlLOC *loc, char CDSPEED) {
 
 
 /* - Type:	PRIVATE
@@ -580,8 +743,7 @@ static short StrKickCD(CdlLOC *loc) {
 			return 0;
 				
 
-	} while (!CdRead2(CdlModeStream|CdlModeSpeed|CdlModeRT));
-
+	} while (!CdRead2(CDSPEED|CdlModeStream|CdlModeRT));
 
 	return 1;
 }
@@ -605,21 +767,36 @@ static u_long *StrGetNextFrame(void) {
 	long		timer = WAIT_TIME;
 	u_long		*addr;                      
 	StHEADER	*sector;                         
-
-    
+	long str_t2;
+	
+	str_t2 = VSync(-1);
     // Get the next frame from the ring buffer.
-	while (StGetNext(&addr, (u_long**) &sector)) {
-			
+
+	if ((str_t2 - p.vsyncBase) - p.endVSync >= -30)
+	{
+		#ifdef DEBUG
+		printf("%i vsyncs to end of stream\n", p.endVSync - (VSyncGetCurrent() - p.vsyncBase));
+		#endif
+		timer = 50000; //prevents stream from locking up at the end
+	}
+	while (StreamPlaying && StGetNext(&addr, (u_long**) &sector)) {
 			if (--timer == 0)
+			{
+				#ifdef DEBUG
+				printf("Vsyncs past end: %i\n", (VSync(-1) - p.vsyncBase) - p.endVSync);
+				printf("Vsyncs to complete wait: %i\n", VSync(-1) - str_t2);
+				#endif
 				return NULL;
+			}
 	}
-
+	
+	//#ifdef DEBUG
+	//printf("Total time waited for frame: %i out of %i\n", WAIT_TIME - timer, WAIT_TIME);
+	//#endif
 
 	dec.frameCount++;				// Update internal frame count.
 
 
-#if defined(TESTING)||defined(FIND_VLCBUF)
-
 	// Check for frame skipping.
 	if (firstFrame) {
 		prevFrameNum = sector->frameCount;
@@ -630,23 +807,30 @@ static u_long *StrGetNextFrame(void) {
 	}
 		
 	prevFrameNum = sector->frameCount;
-	FntPrint("Skipped =  %d\n", numSkipped);
-#endif
+	if (OSD_MENU_TYPE == 2) {
+		FntPrint("Skipped =  %d\n", numSkipped);
+	}
 
 
 #ifdef DEBUG
 	if (dec.frameCount == 1)
 		printf("MOVIE: w = %d, h = %d, sectors = %d\n", 
 				sector->width, sector->height, sector->nSectors);
-
+#endif
+	if (OSD_MENU_TYPE == 2) {
         FntPrint("Frame No. = %d\n", dec.frameCount);
         FntPrint("Width:%d,Height:%d\n",sector->width,sector->height);
         FntPrint("framecount:%d\n",sector->frameCount);
         FntPrint("Type:%d\n",sector->type);
+	}
 
-#endif
 
-			
+		
+	if (dec.rewindSwitch == -1) {
+		dec.frameCount = sector->frameCount;
+		dec.rewindSwitch = 0;
+	}
+	
 	// End of stream checks.
 	if (sector->frameCount > dec.endFrame) {
 	
@@ -686,7 +870,7 @@ static u_long *StrGetNextFrame(void) {
 
 /* ------------------------------------------------------------------------ */
 
-static void StrVLCFrame(u_long *frame) {
+static short StrVLCFrame(u_long *frame) {
 
 
 /* - Type:	PRIVATE
@@ -696,21 +880,21 @@ static void StrVLCFrame(u_long *frame) {
  * - Usage:	VLC decodes the frame's BS. Unlock frame from the ring buffer
  * -		once decoded.
  */
-
+ 
 
 	// If no frame to decode return.
 	if (frame == NULL) {
 #ifdef DEBUG
 		printf("ERROR: MOVIE -- No frame to VLC decode!!\n");
 #endif
-		return;
+		return PLAYSTR_ERROR;
 	}
 
 
-#ifdef TESTING
+if (OSD_MENU_TYPE == 2) {
 		// Print BS Encoded Format (i.e. Version 2 or 3). 
 		FntPrint("BS Ver = %d\n", *((u_short *) frame + 3) );
-#endif
+}
 
 
 #ifdef FIND_VLCBUF
@@ -722,6 +906,8 @@ static void StrVLCFrame(u_long *frame) {
 	dec.vlcId ^= 1;
 	DecDCTvlc(frame, dec.vlcBuffer[dec.vlcId]);
 	StFreeRing(frame);
+	
+	return 0;
 }
 
 /* ------------------------------------------------------------------------ */
@@ -758,34 +944,6 @@ static void	StrDrawDecodeSync(void) {
 
 /* ------------------------------------------------------------------------ */
 
-static short StrFadeOutVol(short *fadeVol) {
-
-
-/* - Type:	PRIVATE
- * -
- * - Param:	fadeVol = (In/Out) Current volume.
- * -
- * - Ret:	1 = Volume completely faded (therefore finish playing the stream).
- * - 		0 = Otherwise.
- * -		
- * -
- * - Usage: Fade out the volume.
- */
-
-
-	if ((*fadeVol -= FADE_VOL_SPD) < 0)
-		*fadeVol = 0;
-
-
-	SsSetSerialVol(SS_SERIAL_A, *fadeVol, *fadeVol);
-
-
-	if (!*fadeVol)
-		return PLAYSTR_USER;			// Flag user exit.
-	else
-		return 0;
-}
-
 /* ------------------------------------------------------------------------ */
 
 static long GetDCToutSize(void) {
@@ -868,40 +1026,31 @@ static void PrintVLCBufSize(void) {
 
 #endif // FIND_VLCBUF
 
-/* ------------------------------------------------------------------------ */
-
-static u_long AllocMem(u_long size) {
-
-
-/* - Type:	PRIVATE
- * -
- * - Param:	size = (In) No. of bytes to allocate.
- * -
- * - Ret:	Base of allocated mem.
- * -
- * - Usage:	Allocate "size" bytes from the heap.
- */
-
- 
-	u_long mem = __heapbase;
-
-	
-	if ((size & 3) != 0)
-		size = (size + 4) & 0xfffffffc;
-
-
-#ifdef DEBUG
-	if ((__heapbase + size) >= (0x80000000 + _ramsize - _stacksize))
-		printf("ERROR: MOVIE -- Not enough memory, can't allocate %d bytes!\n", size);
-	else
-		printf("Allocated %d bytes. Free memory = %d bytes.\n",
-				size,
-				(0x80000000 + _ramsize - _stacksize) - (__heapbase + size)
-				);
-#endif			
-
-
-	__heapbase += size;
-
-	return mem; 
+/*
+static int VSyncsToSectors(int pos, int speed) {
+	if (speed == 0) {
+		speed = 1;
+	}
+	if (speed >= 0x80 || speed < 0) {
+		speed = 2;
+	}
+	if (*(char *)0xbfc7ff52=='E') {
+		return (pos * speed * 75) / 50;
+	} else {
+		return (pos * speed * 75) / 60;
+	}
 }
+*/
+int SectorsToVSyncs(int pos, int speed) {
+	if (speed == 0) {
+		speed = 1;
+	}
+	if (speed >= 0x80 || speed < 0) {
+		speed = 2;
+	}
+	if (*(char *)0xbfc7ff52=='E') {
+		return (pos * 50) / (75 * speed);
+	} else {
+		return (pos * 60) / (75 * speed);
+	}
+}
\ No newline at end of file
diff --git a/MOVIE.H b/MOVIE.H
index d680912..a79ddac 100644
--- a/MOVIE.H
+++ b/MOVIE.H
@@ -39,7 +39,8 @@
  * ---------------------------------------------------------------------------
  */
 
-typedef struct {
+typedef struct 
+{
 		char		*strName;					// Stream file name.
 		CdlLOC		strPos;						// File location
 		short		mode;						// 24-Bit or 16-Bit streaming.
@@ -52,7 +53,8 @@ typedef struct {
 		u_long		endFrame;					// Last frame No.
 		u_long		vlcBufSize;					// Size of each VLC buffer (including header).
 		u_short		volume;						// Left and Right ADPCM volume.
-} StrInfo;
+}
+StrInfo;
 
 typedef struct
 {
@@ -78,8 +80,13 @@ CdSectorHeader;
  * ---------------------------------------------------------------------------
  */
  
-short PlayStream(StrInfo *str, short (*keyHandler)(void));
-
+short PlayStream(StrInfo *str, int endSector, char speed);
+int SectorsToVSyncs(int pos, int speed);
 /* ------------------------------------------------------------------------ */
 
+//extern int vsyncBase;
+//extern int vsyncPauseBase;
+//extern int endVSync;
+extern u_char StreamPlaying;
+
 #endif // __MOVIE_H
diff --git a/SCEECD.C b/SCEECD.C
index edd148c..de034f0 100644
--- a/SCEECD.C
+++ b/SCEECD.C
@@ -31,15 +31,105 @@
 *	11/03/98	Mike Kav        Created
 */
 
+#define FORM1_SIZE     2048 			  
+#define Sectors(x) ((x+FORM1_SIZE-1)/FORM1_SIZE)
+
 #include "SCEEcd.h"
 #include "main.h"
+#include "control.h"
 
 unsigned char loadbuf[2048];
 
-extern EXTENDEDFILEDETAILS fileDetails[1000];
+extern EXTENDEDFILEDETAILS* fileDetails;
 extern DB		db[2];		
 extern short	cdb;							// Current double buffer.
 
+extern char autorun;
+//extern short datracks; //crashes
+
+//extern char* currentPath;
+
+char* CD_REGIONS[] =
+{
+	"of America",
+	"(Europe)",
+	"World wide",
+	"Inc."
+};
+
+int basepos = 0;
+int basesize = 0;
+
+void LoadCdFile(EXTENDEDFILEDETAILS file, u_long* addr) //Need to malloc3 the memory first
+{
+	CdlLOC filePos;
+	int numSectors;
+	int mode = 0;
+	//could malloc3 addr if addr is 0. would have to change to u_long*
+	//addr = malloc3(Sectors(file.size) * 2048);
+	CdIntToPos(file.pos,&filePos);
+
+retry:
+
+	if(!CdControlB(CdlSeekL,(unsigned char *)&filePos, 0))
+	{
+		printf("ERROR: could not do seek\n");  
+		goto retry;
+	}                               
+
+	numSectors = Sectors(file.size);
+	mode |= CdlModeSpeed;
+
+	if(!CdRead(numSectors,addr,mode))
+	{
+		printf("ERROR: could not execute read\n");  
+		goto retry;
+	}                               
+	while (CdReadSync(1,0) > 0 );
+	//CdReadSync(0, 0);
+	return;
+}
+
+
+int FindFileDetails(EXTENDEDFILEDETAILS* efd, char* LongName)
+{
+	FILEDETAILS fd;
+	int result;
+	//char* nameptr;
+	//char *nameptr = currentPath;
+	//printf("Size Init: %i Pos Init: %i Path Init: %s\n", efd->size, efd->pos, currentPath);
+	if (efd->size == 0 || efd->pos == 0)
+	{
+		//nameptr = malloc3(96);
+		//strncpy(nameptr, LongName, 96);
+		if (LongName) // !efd->filename[0] && 
+		{
+			//printf("string for searchfile: %s\n", LongName);
+			result = SCEECdSearchFile(strchr(LongName, '\\'), &fd);
+			//printf("result %i (s:%i p:%i) from %s\n", result, fd.size, fd.pos, strchr(LongName, '\\'));
+			if (result)
+			{
+				efd->size = fd.size;
+				efd->pos = fd.pos;
+				//free3(nameptr);
+				return result;
+			}
+		}
+		CreatePath(efd->name);
+		strcpy(currentPath + strlen(currentPath), ";1");
+		
+		result = SCEECdSearchFile(currentPath, &fd);
+		//strncpy(nameptr, currentPath, 96);
+		CreatePath("..");
+		efd->size = fd.size;
+		efd->pos = fd.pos;
+		//printf("Size found: %i Pos found: %i Final Path: %s\n", efd->size, efd->pos, currentPath);
+		//free3(nameptr);
+		return result;
+	}
+	return 1;
+}
+
 /*
 *
 *	NAME		void cd_read(long size,long loc,char* buf)
@@ -139,7 +229,6 @@ int SCEECdSearchFile(char *name, FILEDETAILS *fp)
 	int i;
 	int secNum, numSectors;
 	int numBytes;
-
         // Check we have a root directory
 	if(*name!='\\')
 		return(0);
@@ -285,187 +374,6 @@ int CheckISO(void)
 	return 0;
 }
 
-/*
-*
-*	NAME		void displayPVD(void)
-*
-*	FUNCTION	Prints out Primary Volume Descriptor details
-*
-*	NOTES		The PVD contains details such as system id, 
-*				volume id, path tables, and important information
-*				such as the root directory start point
-*
-*	CHANGED		PROGRAMMER		REASON
-*	-------  	----------  	------
-*	12/03/98	Mike Kav		Created
-*
-*/
-void displayPVD(void)
-{
-	unsigned int lpathsec, optlpathsec;		// path table variables
-
-	// PVD always at sector 16
-	cd_read(1,0x10,(unsigned char *)&loadbuf);
-
-	// Convert lpath values ready to use as a sector location to load
-	lpathsec = makeInt(140);
-	optlpathsec = makeInt(144);
-
-	printf("Primary Volume Descriptor\n");
-	printf("ID :\t\t\t\t%c%c%c%c%c\n", loadbuf[1], loadbuf[2], loadbuf[3], loadbuf[4], loadbuf[5]);
-	printf("Version :\t\t\t%d\n", loadbuf[6]);
-	printf("System ID :\t\t\t"); printString(8, 39);
-	printf("\nVolume Identifier :\t\t"); printString(40, 71);
-	printf("\nVolume Space Size :\t\t%d\n", makeInt(80));
-	printf("Volume Set Size :\t\t%d\n",loadbuf[120]);
-	printf("Volume Sequence Number :\t%d\n", loadbuf[124]);
-	printf("Logical Block Size :\t\t%d\n",makeShort(128));
-	printf("Path Table Size :\t\t%d\n", makeShort(132));
-	printf("L-Path Table Location :\t\t%d\n",lpathsec);
-  	printf("Optional L-Path Table Location :%d\n", optlpathsec);
-	printf("Root directory entry :\n");
-	displayDir(156);
-	printf("Volume Set Identifier :\t\t"); printString(190, 317);
-	printf("\nPublisher Identifier :\t\t"); printString(318, 445);
-	printf("\nData Preparer Identifier :\t"); printString(446, 573);
-	printf("\nApplication Identifier :\t");	printString(574, 701);
-	printf("\nCopyright File Identifier :\t"); printString(702, 738);
-	printf("\nAbstract File Identifier :");	printString(739, 775);
-	printf("\nBibliography File Identifier :");	printString(776, 812);
-	printf("\nVolume Creation Date/Time :\t");
-	displayTime(813);
-	printf("\nVolume Modification Date/Time :\t");
-	displayTime(830);
-	printf("\nVolume Expiration Date/Time :\t");
-	displayTime(847);
-	printf("\nVolume Effective Date/Time :\t");
-	displayTime(864);
-	printf("\nFile Structure Version :\t%d\n\n",loadbuf[881]);
-
-	if (lpathsec)
-		displayLPath("L-Path", lpathsec);
-	if (optlpathsec)
-		displayLPath("Optional L-Path", optlpathsec);
-
-	return;
-}
-
-/*
-*
-*	NAME		void displayTime (int i)
-*
-*	FUNCTION	formats and displays the date / time
-*				values from a given position in the load
-*				buffer
-*
-*
-*	NOTES		
-*
-*	CHANGED		PROGRAMMER		REASON
-*	-------  	----------  	------
-*	12/03/98	Mike Kav		Created
-*
-*/
-void displayTime (int i)
-{
-	printString(i+6, i+7);
-	printf("/");
-	printString(i+4, i+5);
-	printf("/");
-	printString(i, i+3);
-	printf(" ");
-	printString(i+8, i+9);
-	printf(":");
-	printString(i+10, i+11);
-	printf(":");
-	printString(i+12, i+13);
-	printf(".");
-	printString(i+14, i+15);
-	printf(" GMT offset %d", loadbuf[i+16]);
-}
-
-/*
-*
-*	NAME		void displayDir(int i)
-*
-*	FUNCTION	formats and displays a directory record
-*				from a given position in the load buffer
-*
-*	NOTES		
-*
-*	CHANGED		PROGRAMMER		REASON
-*	-------  	----------  	------
-*	12/03/98	Mike Kav		Created
-*
-*/
-void displayDir(int i)
-{
-	printf("\t\tLength :\t\t\t%d\n", loadbuf[i]);
-	printf("\t\tExtended Attribute Length :\t%d\n", loadbuf[i+1]);
-	printf("\t\tStart Location :\t\t%d\n", makeInt(i+2) );
-	printf("\t\tData Length :\t\t\t%d\n", makeInt(i+10));
-	printf("\t\tRecording Date/Time : ");
-	printf("%d/%d/%d %d:%d:%d GMT offset %d",
-		loadbuf[i+20], loadbuf[i+19], loadbuf[i+18]+1900, loadbuf[i+21], loadbuf[i+22],loadbuf[i+23], loadbuf[i+24]);
-	printf("\n\t\tFile Flags :\t\t\t%d\n", loadbuf[i+25]);
-	printf("\t\tFile Unit Size :\t\t%d\n", loadbuf[i+26]);
-	printf("\t\tInterleave Gap Size :\t\t%d\n", loadbuf[i+27]);
-	printf("\t\tVolume Sequence Number :\t%d\n", makeShort(i+28));
-	printf("\t\tName :\t\t\t");
-	if ((loadbuf[i+33] == 1) && (loadbuf[i+34] == 0))
-		printf(".");
-	else if ((loadbuf[i+33] == 1) && (loadbuf[i+34] == 1))
-		printf("..");
-	else
-		printString(i+34, i+33+loadbuf[i+34]);
-	printf("\n");
-}
-
-/*
-*
-*	NAME		void displayLPath(char *title, unsigned long int sec)
-*
-*	FUNCTION	formats and displays a path table record
-*				from a given position in the load buffer
-*
-*	NOTES		
-*
-*	CHANGED		PROGRAMMER		REASON
-*	-------  	----------  	------
-*	12/03/98	Mike Kav		Created
-*
-*/
-void displayLPath(char *title, unsigned long int sec)
-{
-	int i = 0, j = 1;
-
-	cd_read(1,sec,(unsigned char *)&loadbuf);
-	printf("Sector %d : %s\n\n", sec, title);
-	printf("Ent  ID len  Ext Attr Len     Start  Parent Dir  ID\n");
-	printf("====================================================================\n");
-
-	while (loadbuf[i]) {
-		if (i >= 2048)
-		{
-			sec++;
-			cd_read(1,sec,(unsigned char *)&loadbuf);
-			i -= 2048;
-		}
-		printf("%3d  %6d  %12d  %8d  %10d  ", j++, loadbuf[i], loadbuf[i+1], 
-				makeInt(i+2), makeShort(i+6) );
-		if ((loadbuf[i] == 1) && (loadbuf[i+8] == 0))
-			printf(".");
-		else if ((loadbuf[i] == 1) && (loadbuf[i+8] == 1))
-			printf("..");
-		else
-			printString(i+8, i+7+loadbuf[i]);
-		i += ((loadbuf[i] + 8 + 1) & 0xfffe);
-		printf("\n");
-	}
-
-	printf("=====================================================================\n\n");
-}
-
 /*
 *
 *	NAME		int makeInt(int start)
@@ -520,116 +428,7 @@ short makeShort(int start)
 
 }
 
-/*
-*
-*	NAME		void printString (int first, int last)
-*
-*	FUNCTION	Displays a string from the load buffer
-*
-*	NOTES		
-*
-*	CHANGED		PROGRAMMER		REASON
-*	-------  	----------  	------
-*	12/03/98	Mike Kav		Created
-*
-*/
-void printString (int first, int last)
-{
-	while (first <= last)
-		printf("%c",loadbuf[first++]);
-}
-
-/*
-*
-*	NAME		void PrintDirDetails(int startSec, int numSectors)
-*
-*	FUNCTION	Prints out directory details from the CD
-*
-*	NOTES		Input parameters contain the starting sector position
-*				and the number of sectors to read for that directory
-*				This function will travel down any directories it finds
-*				This function also wraps the array of directories around
-*				at 256 to avoid overwriting memory, to alter this value
-*				just change the dirsToDo array and remove the
-*					todoptr &= 255;
-*				line
-*
-*	CHANGED		PROGRAMMER		REASON
-*	-------  	----------  	------
-*	09/03/98	Mike Kav		Created
-*
-*/
-void PrintDirDetails(int startSec, int numSectors)
-{
-	int i;
-	int j=0;
-	int first,last;
-	unsigned long value;
-	unsigned long length;
-	unsigned long dirsToDo[256][2];
-
-	int todoptr = 0, donext = 0;
-
-	// set up array, place first sector and length in first element of array
-	dirsToDo[todoptr][0] = startSec;
-	dirsToDo[todoptr++][1] = numSectors;
 
-	// Initially todoptr = 1 and donext = 0;
-	while (donext != todoptr)
-	{
-		startSec = dirsToDo[donext][0];
-		numSectors = dirsToDo[donext++][1];
-
-		for(i=0;i<numSectors;i++)
-		{	
-			j=0;
-			// Read Sector, for each entry if file output file details, if dir call this
-			// function with start sector and number of sectors
-		    cd_read(1,(startSec+i),(unsigned char *)&loadbuf);
-
-			printf("Sector %d :\n\n",(startSec+i));
-			printf("Len Ext    Start  DataLen    Recording Date GMT Flg USz IGp Vol ID\n");
-			printf("===============================================================================\n");
-			
-			while(loadbuf[j])
-			{
-				// Get start sector and length for file / dir entry
-				value = makeInt(j+2);
-				length = makeInt(j+10);
-
-				printf("%3d %3d %8d %8d ",loadbuf[j],loadbuf[j+1],value,length);
-				printf("%2d/%2d/%2d %2d:%2d:%2d %3d", loadbuf[j+20], loadbuf[j+19],loadbuf[j+18], loadbuf[j+21], loadbuf[j+22], loadbuf[j+23], loadbuf[j+24]);
-				printf("%4d%4d%4d%4d ", loadbuf[j+25], loadbuf[j+26], loadbuf[j+27], makeShort(j+28));
-
-				// Is it current directory [32] == 1
-				if( (loadbuf[j+32] == 1) && (loadbuf[j+33] == 0))
-					printf(".");
-				else if( (loadbuf[j+32] == 1) && (loadbuf[j+33] == 1))
-					printf("..");
-				else
-				{			
-					// Print file name
-					first = (j+33);
-					last = (j+32+loadbuf[j+32]);
-					printString(first,last);
-
-					if(loadbuf[j+25] & 2)
-					{
-						// new directory, put in array to process later
-						dirsToDo[todoptr][0] = value;
-						dirsToDo[todoptr++][1] = length / 2048;
-						// make sure pointer does go over the array size
-						todoptr &= 255;
-
-					}
-				}
-				// add the number of bytes in the record onto j
-				j+=loadbuf[j];
-				printf("\n");
-			}
-		}
-	}
-}
 
 /*
 *
@@ -742,7 +541,14 @@ int GetDirDetails(int startSec, int numSectors)
 			// Get start sector and length for file / dir entry
 			fileDetails[fileNumber].pos		= makeInt(j+2);
 			fileDetails[fileNumber].size	= makeInt(j+10);
-			strcpy(fileDetails[fileNumber].filename,fileString);
+			strcpy(fileDetails[fileNumber].version,fileString+k-2);
+			fileDetails[fileNumber].type	= GetFileType(fileString);
+			if (fileDetails[fileNumber].type != 0xFB) //MENU_DIR
+			{
+				fileString[k-1] = '\0';
+				fileString[k-2] = '\0';
+			}
+			strcpy(fileDetails[fileNumber].name,fileString);
 			fileNumber++;
 
 			// add the number of bytes in the record onto j
@@ -798,10 +604,18 @@ void IsCdReady(void)
 *	20/03/98	Mike Kav		Created
 *
 */
-void SwapDisk(void)
+void SwapDisk(char manualswap)
 {
 	char result[8];
-
+	u_char session = 1;
+	int kanji;
+	//char nocash = 0;
+	//char manualswap = 0;
+	basepos = 0;
+	basesize = 0;
+	changeResMain(4);
+	//datracks = -1;
+	kanji = KanjiFntOpen(18, 16, 600, 200, 960, 0, 960, 256, 0, 256);
 	// Set mode to standard speed, stop the spindle
 	CdControlB(CdlSetmode, 0, 0);
 	CdControlB(CdlStop,0,0);
@@ -810,14 +624,55 @@ void SwapDisk(void)
 
 	// Wait for CD to stop spinning.
 	CdControlB(CdlNop,0,result);
-	while( !(result[0]&CdlStatStandby) && !(result[0]&CdlStatShellOpen))
+	while(!(manualswap & 0x3) && !(result[0]&CdlStatStandby) && !(result[0]&CdlStatShellOpen))
 	{
 		cdb ^= 1;
 
 		CdControlB(CdlNop,0,result);
-		FntPrint("\tOpen lid and swap disk\n");
+		KanjiFntPrint(kanji, "~p\tOpen lid and swap disc\n\n"); //\t before all lines
+		KanjiFntPrint(kanji, "~p\tX - Boot next disc now\n");
+		
+		KanjiFntPrint(kanji, "~p\tO - Nocash %s\n", (manualswap & 0x4) ? "Lock (Disc Unlocked)" : "Unlock");
+		//printf("s:%X\n", manualswap);
+		KanjiFntPrint(kanji, "~p\tTriangle - Autoboot game (%s)\n", (autorun & 0x2) ? "On" : "Off");
+		KanjiFntPrint(kanji, "~p\tSquare - Autoload menu (%s)\n", (autorun & 0x1) ? "On" : "Off");
+		KanjiFntPrint(kanji, "~p\tStart - Force boot next disc now\n");
+		KanjiFntPrint(kanji, "~p\n\n\tSelect - if disc is %s\n", (manualswap & 0x4) ? "locked" : "already unlocked");
+		
+		if (Pressed(X_KEY))
+		{
+			manualswap |= 1;
+		}
+		if (Pressed(START_KEY))
+		{
+			manualswap |= 3;
+		}
+		else if (Pressed(CIRCLE_KEY))
+		{
+			if (manualswap & 0x4)
+			{
+				CdControlB(0x57, 0, 0);
+				manualswap ^= 0x4;
+			}
+			else
+			{
+				manualswap ^= nocash();
+			}
+		}
+		else if (Pressed(TRIANGLE_KEY))
+		{
+			autorun ^= 0x2;
+		}
+		else if (Pressed(SQUARE_KEY))
+		{
+			autorun ^= 0x1;
+		}
+		else if (Pressed(SELECT_KEY))
+		{
+			manualswap ^= 0x4;
+		}
 		DrawSync(0);
-		FntFlush(-1);
+		KanjiFntFlush(kanji);
 		VSync(0);
 
 		PutDrawEnv(&db[cdb].draw);
@@ -826,15 +681,15 @@ void SwapDisk(void)
 
 	// Lid's opened
 	CdControlB(CdlNop,0,result);
-	while( (result[0]&CdlStatShellOpen) )
+	while( (result[0]&CdlStatShellOpen) && !(manualswap & 0x2))
 	{
 		cdb ^= 1;
 
 		CdControlB(CdlNop,0,result);
 //		FntPrint("\t\t%d,",result[0]);
-		FntPrint("\tInsert disk and close lid\n");
+		KanjiFntPrint(kanji, "~p\tInsert disc and close lid\n");
 		DrawSync(0);
-		FntFlush(-1);
+		KanjiFntFlush(kanji);
 		VSync(0);
 
 		PutDrawEnv(&db[cdb].draw);
@@ -843,14 +698,14 @@ void SwapDisk(void)
 
 	// Lid is shut, wait till TOC has been read
 	CdControlB(CdlGetTN,0,0);
-	while(!(result[0]&CdlStatStandby))
+	while(!(result[0]&CdlStatStandby) && !(manualswap & 0x2))
 	{
 		cdb ^= 1;
 
 		CdControlB(CdlNop,0,result);
-		FntPrint("\tInitialising\n");
+		KanjiFntPrint(kanji, "~p\tInitialising\n");
 		DrawSync(0);
-		FntFlush(-1);
+		KanjiFntFlush(kanji);
 		VSync(0);
 
 		PutDrawEnv(&db[cdb].draw);
@@ -858,7 +713,58 @@ void SwapDisk(void)
 	}
 
 	CdControlB(CdlPause,0,0);
-
+	
+	if ((manualswap & 0x3) && !(manualswap && 0x4))
+	{
+		CdControlB(0x12, &session, result);
+	}
 	// printf("Cd's started up, new disk is in\n");
+	KanjiFntClose();
 	return;
 }
+
+char nocash()
+{
+	char result[16] = {0}; //for debug print
+	u_char test = 0x22;
+	char* region;
+	CdControlB(0x19, &test, result);
+	result[15] = 0;
+	printf("CD Region: %s (%X) (%x)\n", result, result[4], result[0]);
+	printf("BIOS Region: %s\n", (char *)0xbfc7ff32);
+	switch (result[4])
+	{
+		case 'A':
+			region = CD_REGIONS[0];
+			break;
+		case 'E':
+			region = CD_REGIONS[1];
+			break;
+		case 'N':
+			region = CD_REGIONS[2];
+			break;
+		default:
+			switch (*(char *)0xbfc7ff52)
+			{
+				case 'A':
+					region = CD_REGIONS[0];
+					break;
+				case 'E':
+					region = CD_REGIONS[1];
+					break;
+				default:
+					return 0;
+			}
+			break;
+	}
+	printf("Unlocking for %s...\n", region);
+	CdControlB(0x50, 0, result);
+	CdControlB(0x51, "Licensed by", result);
+	CdControlB(0x52, "Sony", result);
+	CdControlB(0x53, "Computer", result);
+	CdControlB(0x54, "Entertainment", result);
+	CdControlB(0x55, region, result);
+	CdControlB(0x56, 0, result);
+	printf("Unlock complete.\n");
+	return 4;
+}
\ No newline at end of file
diff --git a/SCEECD.H b/SCEECD.H
index 2efbe48..2374bf8 100644
--- a/SCEECD.H
+++ b/SCEECD.H
@@ -8,6 +8,9 @@
 #include <libspu.h>
 #include <libsnd.h>
 
+#include <strings.h>
+//#include <malloc.h>
+
 typedef struct
 {
         int pos;
@@ -18,25 +21,35 @@ typedef struct
 {
         int pos;
         int size;
-		char filename[15];
+		//char filename[15]; //Needed for LoadExec
+		char version[3]; //alignment, loadexec etc can use name or 
+		u_char type;
+		//short track;
+		char name[64];
+		int basepos; // Also used for track
+		int basesize;
 } EXTENDEDFILEDETAILS;
 
+extern char currentPath[((8*8)+15+9)];
+
 int SCEECdSearchFile(char *name, FILEDETAILS *fp);
-void displayPVD(void);
-void PrintDirDetails(int startSec, int numSectors);
+
+
 
 // Functions only used by SCEECdSearchFile() and displayPVD()
 void    cd_read(long size,long loc,char* buf);
 void    GetRootDirDetails(int *secNum, int *numSectors);
 int     IsFileInDir(int *startSec, int *numSectors, char *name);
-void	printString (int first, int last);
+
 int		makeInt(int start);
 short	makeShort(int start);
-void	displayTime (int i);
-void	displayDir(int i);
-void	displayLPath(char *title, unsigned long int sec);
 void	IsCdReady(void);
-void	SwapDisk(void);
+void	SwapDisk(char manualswap);
 
 // Function only used by GetDirDetails()
 int GetNumDirEntries(int startSec, int numSectors);
+
+
+void LoadCdFile(EXTENDEDFILEDETAILS file, u_long* addr);
+int FindFileDetails(EXTENDEDFILEDETAILS* efd, char* LongName);
+char nocash();
\ No newline at end of file
diff --git a/TIMVIEW.C b/TIMVIEW.C
index 912cefb..6395d0c 100644
--- a/TIMVIEW.C
+++ b/TIMVIEW.C
@@ -27,10 +27,12 @@
 #include <libspu.h>
 #include <libsnd.h>
 #include <libgs.h>
+#include <malloc.h>
 
 #include "main.h"
 #include "sceecd.h"
 #include "timview.h"
+//#include "state.h"
 #include "control.h"
 
 #define FORM1_SIZE     2048 			  
@@ -41,8 +43,8 @@ extern DB		db[2];
 extern short	cdb;							// Current double buffer.
 
 // need to malloc this at some point, TIM image buffer
-unsigned char loadbuf[327680];
-u_long* addr = (unsigned long *)&loadbuf[0];
+//unsigned char loadbuf[327680];
+u_long* addr;
 
 // Polygon details for displaying texture
 POLY_FT4 poly;
@@ -53,15 +55,11 @@ TEXTURE_INFO texture;
 
 
 // Screen resolution values
-int xSize = 3;
-int resX =512;
-int resY=256;
+int xSize = 4;
+int resX=640;
+int resY=240;
 
-#define	FRAME_X			512
-#define	FRAME_Y			256
-
-#define SCREEN_X		0
-#define SCREEN_Y		18	
+extern short SCREEN_X, SCREEN_Y, FRAME_X, FRAME_Y;
 
 int		scrTable[5] =
 		{256, 320, 368, 512, 640};
@@ -87,6 +85,7 @@ void TimViewer(EXTENDEDFILEDETAILS file)
 	int numSectors;
 	int mode = 0;
 
+	addr = malloc3(Sectors(file.size) << 11); //2048
 	CdIntToPos(file.pos,&filePos);
 
 retry:
@@ -111,7 +110,11 @@ retry:
 	// Load texture to VRAM
 	texture.addr=addr;
 	if(!loadTIM(&texture))
+	{
+		free3(addr);
 		return;
+	}
+
 
 	// Initialise poly
     SetPolyFT4(&poly);
@@ -145,6 +148,7 @@ retry:
     }
 
 	ViewTim();
+	free3(addr);
 
 	return;
 }
@@ -168,7 +172,7 @@ int	loadTIM(TEXTURE_INFO *info)
 {
 	TIM_IMAGE	image;		/* TIM header */
 
-        RECT srcRect;
+        //RECT srcRect; //warning
 	
 	if( OpenTIM(info->addr) == 0)
 			;
@@ -281,15 +285,16 @@ void ViewTim(void)
 	int polyH=texture.texture_h;
 	int initPolyY, initPolyX, initPolyW, initPolyH;
 
-	short block = INPUT_DELAY;
-
+	//short block = INPUT_DELAY;
+	
+	resY=FRAME_Y;
 	// Hold initial values ready for reset
 	initPolyY = polyY;
 	initPolyX = polyX;
 	initPolyW = polyW;
 	initPolyH = polyH;
 
-	while(!Pressed(TRIANGLE_KEY))
+	while(!BPressed(TRIANGLE_KEY))
 	{
 		cdb ^= 1;
 
@@ -303,51 +308,51 @@ void ViewTim(void)
 		FntPrint(fIdA, "Select   = Reset Texture\n");
 		FntPrint(fIdA, "Start    = Change Resolution\n");
 
-		if (Pressed(DOWN_KEY))
+		if (BPressed(DOWN_KEY))
 		{
 			if(polyY < 512)
 				polyY++ ;
 		}
-		else if (Pressed(UP_KEY))
+		else if (BPressed(UP_KEY))
 		{
 			if(polyY > -512)
 				polyY--;
 		}
 		
-		if (Pressed(LEFT_KEY))
+		if (BPressed(LEFT_KEY))
 		{
 			if(polyX > -320)
 				polyX--;
 		}
-		else if (Pressed(RIGHT_KEY))
+		else if (BPressed(RIGHT_KEY))
 		{
 			if(polyX < 640)
 				polyX++;
 		}
 
-		if (Pressed(L1_KEY))
+		if (BPressed(L1_KEY))
 		{
 				if(polyH < 511)
 				polyH++;
 		}
-		else if (Pressed(L2_KEY))
+		else if (BPressed(L2_KEY))
 		{
 				if(polyH > 0)
 				polyH--;
 		}
 
-		if (Pressed(R1_KEY))
+		if (BPressed(R1_KEY))
 		{
 				if(polyW < 1023)
 				polyW++;
 		}
-		else if (Pressed(R2_KEY))
+		else if (BPressed(R2_KEY))
 		{
 				if(polyW > 0)
 				polyW--;
 		}
 
-		if (Pressed(SELECT_KEY))
+		if (BPressed(SELECT_KEY))
 		{
 			polyY = initPolyY;
 			polyX = initPolyX;
@@ -355,21 +360,11 @@ void ViewTim(void)
 			polyH = initPolyH;
 		}
 
-		if (!block && Pressed(START_KEY))
+		if (Pressed(START_KEY))
 		{
-			if (xSize == 4)
-			     xSize = 0;
-			else
-			     xSize++;
-			resX=scrTable[xSize];
-			resY=FRAME_Y;
-			changeRes();
-			block = INPUT_DELAY;
+			changeResMain(-1);
 		}
 
-		if (block > 0)
-			block--;
-
 		setXYWH(&poly, polyX, polyY, polyW, polyH);
 
 		DrawPrim(&poly);
@@ -383,13 +378,32 @@ void ViewTim(void)
 	}
 
         // reset to original resolution
-        resX=scrTable[3];
-        resY=FRAME_Y;
-        changeRes();
+        //resX=scrTable[4];
+        //resY=FRAME_Y;
+        //changeRes();
 
         return;
 }
 
+void changeResMain(int x)
+{
+	if (xSize == 4)
+	{
+		xSize = 0;
+	}
+	else
+	{
+		xSize++;
+	}
+	if (x <= 4 && x >= 0)
+	{
+		xSize = x;
+	}
+	resX=scrTable[xSize];
+	resY=FRAME_Y;
+	changeRes();
+}
+
 /*
 *
 *	NAME		void changeRes(void)
diff --git a/TIMVIEW.H b/TIMVIEW.H
index 6f60bba..7a6aa55 100644
--- a/TIMVIEW.H
+++ b/TIMVIEW.H
@@ -11,4 +11,5 @@ typedef struct {
 void TimViewer(EXTENDEDFILEDETAILS file);
 int	loadTIM(TEXTURE_INFO *info);
 void ViewTim(void);
-void changeRes(void);
\ No newline at end of file
+void changeRes(void);
+void changeResMain(int x);
\ No newline at end of file
diff --git a/debugcd.c b/debugcd.c
new file mode 100644
index 0000000..ef319b7
--- /dev/null
+++ b/debugcd.c
@@ -0,0 +1,300 @@
+#include "sceecd.h"
+
+extern char loadbuf[2048];
+
+//extern EXTENDEDFILEDETAILS* fileDetails;
+extern DB		db[2];		
+extern short	cdb;							// Current double buffer.
+
+
+/*
+*
+*	NAME		void printString (int first, int last)
+*
+*	FUNCTION	Displays a string from the load buffer
+*
+*	NOTES		
+*
+*	CHANGED		PROGRAMMER		REASON
+*	-------  	----------  	------
+*	12/03/98	Mike Kav		Created
+*
+*/
+void printString (int first, int last)
+{
+	while (first <= last)
+		printf("%c",loadbuf[first++]);
+}
+
+/*
+*
+*	NAME		void PrintDirDetails(int startSec, int numSectors)
+*
+*	FUNCTION	Prints out directory details from the CD
+*
+*	NOTES		Input parameters contain the starting sector position
+*				and the number of sectors to read for that directory
+*				This function will travel down any directories it finds
+*				This function also wraps the array of directories around
+*				at 256 to avoid overwriting memory, to alter this value
+*				just change the dirsToDo array and remove the
+*					todoptr &= 255;
+*				line
+*
+*	CHANGED		PROGRAMMER		REASON
+*	-------  	----------  	------
+*	09/03/98	Mike Kav		Created
+*
+*/
+void PrintDirDetails(int startSec, int numSectors)
+{
+	int i;
+	int j=0;
+	int first,last;
+	unsigned long value;
+	unsigned long length;
+	unsigned long dirsToDo[256][2];
+
+	int todoptr = 0, donext = 0;
+
+	// set up array, place first sector and length in first element of array
+	dirsToDo[todoptr][0] = startSec;
+	dirsToDo[todoptr++][1] = numSectors;
+
+	// Initially todoptr = 1 and donext = 0;
+	while (donext != todoptr)
+	{
+		startSec = dirsToDo[donext][0];
+		numSectors = dirsToDo[donext++][1];
+
+		for(i=0;i<numSectors;i++)
+		{	
+			j=0;
+			// Read Sector, for each entry if file output file details, if dir call this
+			// function with start sector and number of sectors
+		    cd_read(1,(startSec+i),(unsigned char *)&loadbuf);
+
+			printf("Sector %d :\n\n",(startSec+i));
+			printf("Len Ext    Start  DataLen    Recording Date GMT Flg USz IGp Vol ID\n");
+			printf("===============================================================================\n");
+			
+			while(loadbuf[j])
+			{
+				// Get start sector and length for file / dir entry
+				value = makeInt(j+2);
+				length = makeInt(j+10);
+
+				printf("%3d %3d %8d %8d ",loadbuf[j],loadbuf[j+1],value,length);
+				printf("%2d/%2d/%2d %2d:%2d:%2d %3d", loadbuf[j+20], loadbuf[j+19],loadbuf[j+18], loadbuf[j+21], loadbuf[j+22], loadbuf[j+23], loadbuf[j+24]);
+				printf("%4d%4d%4d%4d ", loadbuf[j+25], loadbuf[j+26], loadbuf[j+27], makeShort(j+28));
+
+				// Is it current directory [32] == 1
+				if( (loadbuf[j+32] == 1) && (loadbuf[j+33] == 0))
+					printf(".");
+				else if( (loadbuf[j+32] == 1) && (loadbuf[j+33] == 1))
+					printf("..");
+				else
+				{			
+					// Print file name
+					first = (j+33);
+					last = (j+32+loadbuf[j+32]);
+					printString(first,last);
+
+					if(loadbuf[j+25] & 2)
+					{
+						// new directory, put in array to process later
+						dirsToDo[todoptr][0] = value;
+						dirsToDo[todoptr++][1] = length / 2048;
+						// make sure pointer does go over the array size
+						todoptr &= 255;
+
+					}
+				}
+				// add the number of bytes in the record onto j
+				j+=loadbuf[j];
+				printf("\n");
+			}
+		}
+	}
+}
+
+/*
+*
+*	NAME		void displayPVD(void)
+*
+*	FUNCTION	Prints out Primary Volume Descriptor details
+*
+*	NOTES		The PVD contains details such as system id, 
+*				volume id, path tables, and important information
+*				such as the root directory start point
+*
+*	CHANGED		PROGRAMMER		REASON
+*	-------  	----------  	------
+*	12/03/98	Mike Kav		Created
+*
+*/
+void displayPVD(void)
+{
+	unsigned int lpathsec, optlpathsec;		// path table variables
+
+	// PVD always at sector 16
+	cd_read(1,0x10,(unsigned char *)&loadbuf);
+
+	// Convert lpath values ready to use as a sector location to load
+	lpathsec = makeInt(140);
+	optlpathsec = makeInt(144);
+
+	printf("Primary Volume Descriptor\n");
+	printf("ID :\t\t\t\t%c%c%c%c%c\n", loadbuf[1], loadbuf[2], loadbuf[3], loadbuf[4], loadbuf[5]);
+	printf("Version :\t\t\t%d\n", loadbuf[6]);
+	printf("System ID :\t\t\t"); printString(8, 39);
+	printf("\nVolume Identifier :\t\t"); printString(40, 71);
+	printf("\nVolume Space Size :\t\t%d\n", makeInt(80));
+	printf("Volume Set Size :\t\t%d\n",loadbuf[120]);
+	printf("Volume Sequence Number :\t%d\n", loadbuf[124]);
+	printf("Logical Block Size :\t\t%d\n",makeShort(128));
+	printf("Path Table Size :\t\t%d\n", makeShort(132));
+	printf("L-Path Table Location :\t\t%d\n",lpathsec);
+  	printf("Optional L-Path Table Location :%d\n", optlpathsec);
+	printf("Root directory entry :\n");
+	displayDir(156);
+	printf("Volume Set Identifier :\t\t"); printString(190, 317);
+	printf("\nPublisher Identifier :\t\t"); printString(318, 445);
+	printf("\nData Preparer Identifier :\t"); printString(446, 573);
+	printf("\nApplication Identifier :\t");	printString(574, 701);
+	printf("\nCopyright File Identifier :\t"); printString(702, 738);
+	printf("\nAbstract File Identifier :");	printString(739, 775);
+	printf("\nBibliography File Identifier :");	printString(776, 812);
+	printf("\nVolume Creation Date/Time :\t");
+	displayTime(813);
+	printf("\nVolume Modification Date/Time :\t");
+	displayTime(830);
+	printf("\nVolume Expiration Date/Time :\t");
+	displayTime(847);
+	printf("\nVolume Effective Date/Time :\t");
+	displayTime(864);
+	printf("\nFile Structure Version :\t%d\n\n",loadbuf[881]);
+
+	if (lpathsec)
+		displayLPath("L-Path", lpathsec);
+	if (optlpathsec)
+		displayLPath("Optional L-Path", optlpathsec);
+
+	return;
+}
+
+/*
+*
+*	NAME		void displayTime (int i)
+*
+*	FUNCTION	formats and displays the date / time
+*				values from a given position in the load
+*				buffer
+*
+*
+*	NOTES		
+*
+*	CHANGED		PROGRAMMER		REASON
+*	-------  	----------  	------
+*	12/03/98	Mike Kav		Created
+*
+*/
+void displayTime (int i)
+{
+	printString(i+6, i+7);
+	printf("/");
+	printString(i+4, i+5);
+	printf("/");
+	printString(i, i+3);
+	printf(" ");
+	printString(i+8, i+9);
+	printf(":");
+	printString(i+10, i+11);
+	printf(":");
+	printString(i+12, i+13);
+	printf(".");
+	printString(i+14, i+15);
+	printf(" GMT offset %d", loadbuf[i+16]);
+}
+
+/*
+*
+*	NAME		void displayDir(int i)
+*
+*	FUNCTION	formats and displays a directory record
+*				from a given position in the load buffer
+*
+*	NOTES		
+*
+*	CHANGED		PROGRAMMER		REASON
+*	-------  	----------  	------
+*	12/03/98	Mike Kav		Created
+*
+*/
+void displayDir(int i)
+{
+	printf("\t\tLength :\t\t\t%d\n", loadbuf[i]);
+	printf("\t\tExtended Attribute Length :\t%d\n", loadbuf[i+1]);
+	printf("\t\tStart Location :\t\t%d\n", makeInt(i+2) );
+	printf("\t\tData Length :\t\t\t%d\n", makeInt(i+10));
+	printf("\t\tRecording Date/Time : ");
+	printf("%d/%d/%d %d:%d:%d GMT offset %d",
+		loadbuf[i+20], loadbuf[i+19], loadbuf[i+18]+1900, loadbuf[i+21], loadbuf[i+22],loadbuf[i+23], loadbuf[i+24]);
+	printf("\n\t\tFile Flags :\t\t\t%d\n", loadbuf[i+25]);
+	printf("\t\tFile Unit Size :\t\t%d\n", loadbuf[i+26]);
+	printf("\t\tInterleave Gap Size :\t\t%d\n", loadbuf[i+27]);
+	printf("\t\tVolume Sequence Number :\t%d\n", makeShort(i+28));
+	printf("\t\tName :\t\t\t");
+	if ((loadbuf[i+33] == 1) && (loadbuf[i+34] == 0))
+		printf(".");
+	else if ((loadbuf[i+33] == 1) && (loadbuf[i+34] == 1))
+		printf("..");
+	else
+		printString(i+34, i+33+loadbuf[i+34]);
+	printf("\n");
+}
+
+/*
+*
+*	NAME		void displayLPath(char *title, unsigned long int sec)
+*
+*	FUNCTION	formats and displays a path table record
+*				from a given position in the load buffer
+*
+*	NOTES		
+*
+*	CHANGED		PROGRAMMER		REASON
+*	-------  	----------  	------
+*	12/03/98	Mike Kav		Created
+*
+*/
+void displayLPath(char *title, unsigned long int sec)
+{
+	int i = 0, j = 1;
+
+	cd_read(1,sec,(unsigned char *)&loadbuf);
+	printf("Sector %d : %s\n\n", sec, title);
+	printf("Ent  ID len  Ext Attr Len     Start  Parent Dir  ID\n");
+	printf("====================================================================\n");
+
+	while (loadbuf[i]) {
+		if (i >= 2048)
+		{
+			sec++;
+			cd_read(1,sec,(unsigned char *)&loadbuf);
+			i -= 2048;
+		}
+		printf("%3d  %6d  %12d  %8d  %10d  ", j++, loadbuf[i], loadbuf[i+1], 
+				makeInt(i+2), makeShort(i+6) );
+		if ((loadbuf[i] == 1) && (loadbuf[i+8] == 0))
+			printf(".");
+		else if ((loadbuf[i] == 1) && (loadbuf[i+8] == 1))
+			printf("..");
+		else
+			printString(i+8, i+7+loadbuf[i]);
+		i += ((loadbuf[i] + 8 + 1) & 0xfffe);
+		printf("\n");
+	}
+
+	printf("=====================================================================\n\n");
+}
\ No newline at end of file
diff --git a/debugcd.h b/debugcd.h
new file mode 100644
index 0000000..48b70d6
--- /dev/null
+++ b/debugcd.h
@@ -0,0 +1,17 @@
+#include <sys/types.h>
+#include <kernel.h>
+#include <libsn.h>
+#include <libgte.h>
+#include <libgpu.h>
+#include <libetc.h>
+#include <libcd.h>
+#include <libspu.h>
+#include <libsnd.h>
+
+
+void printString (int first, int last);
+void PrintDirDetails(int startSec, int numSectors);
+void displayPVD(void);
+void	displayTime (int i);
+void	displayDir(int i);
+void	displayLPath(char *title, unsigned long int sec);
\ No newline at end of file
diff --git a/make.bat b/make.bat
new file mode 100644
index 0000000..ef093c3
--- /dev/null
+++ b/make.bat
@@ -0,0 +1,13 @@
+del *.cpe
+del *.sym
+del *.map
+del main.exe
+ccpsx -Wunused -comments-c++ -c -O2 -DFINAL -I.. -I. main.c -omain.obj
+ccpsx -Wunused -comments-c++ -c -O2 -DFINAL -I.. -I. SCEEcd.c -oSCEEcd.obj
+ccpsx -Wunused -comments-c++ -c -O2 -DFINAL -I.. -I. control.c -ocontrol.obj
+ccpsx -Wunused -comments-c++ -c -O2 -DFINAL -I.. -I. timview.c -otimview.obj
+ccpsx -Wunused -comments-c++ -c -O2 -DFINAL -I.. -I. movie.c -omovie.obj
+ccpsx -Wunused -comments-c++ -c -O2 -DFINAL -I.. -I. music.c -omusic.obj
+rem aspsx /l datafile.asm
+psylink /m /g @main.lnk,main.cpe,main.sym,main.map
+cpe2x main.cpe
\ No newline at end of file
diff --git a/music.c b/music.c
new file mode 100644
index 0000000..0fa57ec
--- /dev/null
+++ b/music.c
@@ -0,0 +1,2098 @@
+#include <sys/types.h>
+#include <kernel.h>
+#include <libsn.h>
+#include <libgte.h>
+#include <libgpu.h>
+#include <libetc.h>
+#include <libcd.h>
+#include <libspu.h>
+#include <libsnd.h>
+#include <libgs.h>
+
+#include <malloc.h>
+#include <strings.h>
+#include <ctype.h>
+
+#include <xmplay.h>
+//#include "main.h"
+#include "sceecd.h"
+#include "music.h"
+#include "hitmod.h"
+//#include "state.h"
+#include "movie.h"
+//#include "intro.h" //TEMP XM TEST
+#include "timview.h"
+
+#define FORM1_SIZE     2048 			  
+#define Sectors(x) ((x+FORM1_SIZE-1)/FORM1_SIZE)
+
+#define MIN_VOL				0
+#define MAX_VOL				127 //127 for seq, 255 for XA/DA? 
+//#define DEBUG 1
+
+unsigned char* xmData;
+unsigned char* vhData;
+unsigned char* vbData;
+
+//u_long* seqData;
+//u_long* vhDataLong;
+//u_long* vbDataLong;
+short seq1, vab1 = 0;
+//u_char* seqTable;
+int seqLength = 0;
+int seqMin = 0;
+short seqVoices = 0;
+u_char seqSpeed = 0;
+
+u_long* songData;
+u_long* libData;
+
+extern int basepos;
+extern int basesize;
+
+int VABID;
+int Song_ID1 =-1;
+u_char *XMHeaderAddr;
+u_char *XMAddr;
+
+u_char MusicType = 0;
+u_char StreamPlaying = 0;
+
+u_long XAChannels = 0;
+CdlCB OldCallback;
+//short septrk;
+
+//u_char ChannelOut;
+
+//int	vsyncBase;
+//int endVSync;
+//int vsyncPauseBase; //Set this to corrent vsync when paused.
+
+ParamsShared p =
+{
+	0, //vsyncBase
+	0, //endVSync
+	0, //vsyncPauseBase
+	STR_MODE24, //streamMode
+	STR_BORDERS_ON, //borders
+	127, //volume (MAX_VOL)
+	CHANNEL_STEREO, //musicChannels
+	127, //mvolume
+	1, //force
+	0, //panregion
+	SS_TICK240, //tick mode
+	0, //loops
+	0, //minutes
+	0, //seconds
+	0, //frames
+	20, //inputspeed
+	1, //repeatspeed
+	0, //seekminutes
+	20, //seekseconds
+	0, //seekframes
+	0, //revmode
+	127, //revvol
+	96, //revdepth
+	64, //revdelay
+	32, //revfeedback
+	1, //displaytime
+	120, //tempo
+	0, //pausestart
+	//1, //shiftjis
+	1 //realloc
+};
+
+char seq_table[SS_SEQ_TABSIZ * 1 * 16];
+
+/*
+extern int vsyncBase;
+extern int endVSync;
+extern int vsyncPauseBase; //internal use so not in shared parameters
+*/
+
+//Main
+
+void OSDSelect(u_char type)
+{
+	//printf("OSD SELECT %i\n", type);
+	switch (type) {
+		case OSD_SETTIME:
+			if (seqLength) {
+				SeekMusic(MusicType, 1, p.frames, seqMin, seqMin + seqLength, p.seconds, p.minutes, seqSpeed);
+			}
+			break;
+		case OSD_TEMPO:
+			SetTempo(p.tempo, MusicType);
+			break;
+		case OSD_TICKMODE:
+			if (MusicType == MUSIC_XM && p.tickmode >= 60 && p.tickmode <= 240)
+			{
+				XM_SetSpeed(Song_ID1, p.tickmode - 60);
+			}
+			break;
+	}
+	return;
+}
+
+void OSDIncDec(int val, u_char type)
+{
+	#ifdef DEBUG
+	printf("OSD INC %i type %i\n", val, type);
+	#endif
+	switch (type) {
+		case OSD_VOLUME:
+			p.volume = SetVolume(p.volume + val, MusicType);
+			break;
+		case OSD_CHANNELS:
+			p.musicChannels = SetChannels(p.musicChannels + val, MusicType);
+			break;
+		case OSD_MVOLUME:
+			p.mvolume = SetMVolume(p.mvolume + val, type);
+			break;
+		case OSD_PANREGION:
+			p.panregion = constrain(p.panregion + val, 0, 3);
+			//if (force >= 4) {}
+			//printf("PAL: %i S3M: %i\n", p.panregion >> 1, p.panregion & 1);
+			break;
+		case OSD_TICKMODE:
+			if (p.tickmode + val > 6 && p.tickmode + val < 60) {
+				if (val > 0) {
+					p.tickmode = 60;
+				} else {
+					p.tickmode = 6;
+				}
+			} else {
+				p.tickmode = constrain(p.tickmode + val, 0, 240);
+			}
+			if (MusicType == MUSIC_NEWSEQ && p.force >= 4)
+			{
+				//printf("Tick Mode: %i\n", 
+				SetTickMode(p.tickmode);
+				//);
+			}
+			break;
+		case OSD_LOOPS:
+			p.loops = constrain(p.loops + val, 0, 9999);
+			break;
+		case OSD_BORDERS:
+			p.borders = constrain(p.borders + val, 0, 1);
+			break;
+		case OSD_BITDEPTH:
+			p.streamMode = constrain(p.streamMode + val, 0, 1);
+			break;
+		case OSD_MINUTES:
+			p.minutes = constrain(p.minutes + val, 0, 9999);
+			break;
+		case OSD_SECONDS:
+			p.seconds = constrain(p.seconds + val, 0, 9999);
+			break;
+		case OSD_FRAMES:
+			p.frames = constrain(p.frames + val, 0, 9999);
+			break;
+		case OSD_REPEATDELAY:
+			p.inputspeed = constrain(p.inputspeed + val, 0, 9999);
+			break;
+		case OSD_REPEATSPEED:
+			p.repeatspeed = constrain(p.repeatspeed + val, 0, 9999);
+			break;
+		case OSD_FORCE:
+			p.force = constrain(p.force + val, 0, 5);
+			break;
+		case OSD_SEEKMINUTES:
+			p.seekminutes = constrain(p.seekminutes + val, 0, 9999);
+			break;
+		case OSD_SEEKSECONDS:
+			p.seekseconds = constrain(p.seekseconds + val, 0, 9999);
+			break;
+		case OSD_SEEKFRAMES:
+			p.seekframes = constrain(p.seekframes + val, 0, 9999);
+			break;
+		case OSD_REVMODE:
+			p.revmode = SetReverb(p.revmode + val, p.revdepth, MusicType);
+			break;
+		case OSD_REVDEPTH:
+			p.revdepth = SetReverbDepth(p.revdepth + val, MusicType);
+			break;
+		case OSD_REVVOL:
+			p.revvol = SetReverbVolume(p.revvol + val, MusicType);
+			break;
+		case OSD_REVDELAY:
+			p.revdelay = SetReverbDelay(p.revdelay + val, MusicType);
+			break;
+		case OSD_REVFEEDBACK:
+			p.revfeedback = SetReverbFeedback(p.revfeedback + val, MusicType);
+			break;
+		case OSD_DISPTIME:
+			p.displaytime = constrain(p.displaytime + val, 0, 1);
+			break;
+		case OSD_TEMPO:
+			p.tempo = constrain(p.tempo + val, 1, 9999);
+			break;
+		case OSD_PAUSE:
+			p.pausestart = constrain(p.pausestart + val, 0, 1);
+			break;
+		//case OSD_SJIS:
+		//	p.shiftjis = constrain(p.shiftjis + val, 0, 1);
+		//	break;
+		case OSD_REALLOC:
+			p.realloc = constrain(p.realloc + val, 0, 1);
+			break;
+		default:
+			break;
+	}
+	return;
+}
+
+short SetReverb(short mode, short depth, u_char type)
+{
+	//SpuReverbAttr rev_attr;
+	if (type == MUSIC_NONE)
+	{
+		type = MusicType;
+	}
+	mode = constrain(mode, 0, 9);
+	depth = constrain(depth, 0, 127);
+	switch (type) {
+		case MUSIC_STR:
+		case MUSIC_STR1X:
+		case MUSIC_STR2X:
+		case MUSIC_XA:
+		case MUSIC_XA1X:
+		case MUSIC_XA2X:
+		case MUSIC_NEWSEQ:
+		case MUSIC_DA:
+			SpuClearReverbWorkArea(mode);
+			SsUtReverbOn();
+			SsUtSetReverbType(mode);
+			SsUtSetReverbDepth(depth, depth);
+			break;
+		case MUSIC_MOD:
+			if (p.force < 5)
+			{
+				break;
+			}
+		case MUSIC_XM:
+		case MUSIC_VAG:
+			/*
+			printf("reverb status: %i\n", SpuSetReverb(SPU_ON));
+			rev_attr.mask = SPU_REV_MODE | SPU_REV_DEPTHL | SPU_REV_DEPTHR;
+			rev_attr.depth.left = (depth << 8) + (depth << 1);
+			rev_attr.depth.right = (depth << 8) + (depth << 1);
+			rev_attr.mode = mode;// | SPU_REV_MODE_CLEAR_WA;
+			SpuSetReverbModeParam(&rev_attr);
+			*/
+			SpuSetReverb(SPU_ON);
+			SpuSetReverbVoice(SPU_ON, SPU_ALLCH);
+			SpuSetReverbModeType(mode | SPU_REV_MODE_CLEAR_WA);
+			SpuSetReverbModeDepth((depth << 8) + (depth << 1), (depth << 8) + (depth << 1));
+			break;
+	}
+	return mode;
+}
+
+short SetReverbDepth(short depth, u_char type)
+{
+	if (type == MUSIC_NONE)
+	{
+		type = MusicType;
+	}
+	depth = constrain(depth, 0, 127);
+	switch (type)
+	{
+		case MUSIC_STR:
+		case MUSIC_STR1X:
+		case MUSIC_STR2X:
+		case MUSIC_XA:
+		case MUSIC_XA1X:
+		case MUSIC_XA2X:
+		case MUSIC_NEWSEQ:
+		case MUSIC_DA:
+			SsUtSetReverbDepth(depth, depth);
+			break;
+		case MUSIC_MOD:
+			if (p.force < 5)
+			{
+				break;
+			}
+		case MUSIC_XM:
+		case MUSIC_VAG:
+			SpuSetReverbModeDepth((depth << 8) + (depth << 1), (depth << 8) + (depth << 1));
+			break;
+	}
+	return depth;
+}
+
+short SetReverbVolume(short vol, u_char type)
+{
+	if (type == MUSIC_NONE)
+	{
+		type = MusicType;
+	}
+	vol = constrain(vol, 0, 127);
+	switch (type)
+	{
+		case MUSIC_STR:
+		case MUSIC_STR1X:
+		case MUSIC_STR2X:
+		case MUSIC_XA:
+		case MUSIC_XA1X:
+		case MUSIC_XA2X:
+		case MUSIC_NEWSEQ:
+		case MUSIC_DA:
+			SsSetRVol(vol, vol);
+			break;
+	}
+	return vol;
+}
+
+short SetReverbDelay(short delay, u_char type)
+{
+	if (type == MUSIC_NONE)
+	{
+		type = MusicType;
+	}
+	delay = constrain(delay, 0, 127);
+	switch (type)
+	{
+		case MUSIC_STR:
+		case MUSIC_STR1X:
+		case MUSIC_STR2X:
+		case MUSIC_XA:
+		case MUSIC_XA1X:
+		case MUSIC_XA2X:
+		case MUSIC_NEWSEQ:
+		case MUSIC_DA:
+			SsUtSetReverbDelay(delay);
+			break;
+		case MUSIC_MOD:
+			if (p.force < 5)
+			{
+				break;
+			}
+		case MUSIC_XM:
+		case MUSIC_VAG:
+			SpuSetReverbModeDelayTime(delay);
+			break;
+	}
+	return delay;
+}
+
+short SetReverbFeedback(short feedback, u_char type)
+{
+	if (type == MUSIC_NONE)
+	{
+		type = MusicType;
+	}
+	feedback = constrain(feedback, 0, 127);
+	switch (type)
+	{
+		case MUSIC_STR:
+		case MUSIC_STR1X:
+		case MUSIC_STR2X:
+		case MUSIC_XA:
+		case MUSIC_XA1X:
+		case MUSIC_XA2X:
+		case MUSIC_NEWSEQ:
+		case MUSIC_DA:
+			SsUtSetReverbFeedback(feedback);
+			break;
+		case MUSIC_MOD:
+			if (p.force < 5)
+			{
+				break;
+			}
+		case MUSIC_XM:
+		case MUSIC_VAG:
+			SpuSetReverbModeFeedback(feedback);
+			break;
+	}
+	return feedback;
+}
+
+int OSDGetVal(u_char type)
+{
+	switch (type) {
+		case OSD_VOLUME:
+			return p.volume;
+		case OSD_CHANNELS:
+			return p.musicChannels;
+		case OSD_MVOLUME:
+			return p.mvolume;
+		case OSD_PANREGION:
+			return p.panregion;
+		case OSD_TICKMODE:
+			return p.tickmode;
+		case OSD_LOOPS:
+			return p.loops;
+		case OSD_BORDERS:
+			return p.borders;
+		case OSD_BITDEPTH:
+			return p.streamMode;
+		case OSD_MINUTES:
+			return p.minutes;
+		case OSD_SECONDS:
+			return p.seconds;
+		case OSD_FRAMES:
+			return p.frames;
+		case OSD_REPEATDELAY:
+			return p.inputspeed;
+		case OSD_REPEATSPEED:
+			return p.repeatspeed;
+		case OSD_FORCE:
+			return p.force;
+		case OSD_SEEKMINUTES:
+			return p.seekminutes;
+		case OSD_SEEKSECONDS:
+			return p.seekseconds;
+		case OSD_SEEKFRAMES:
+			return p.seekframes;
+		case OSD_REVMODE:
+			return p.revmode;
+		case OSD_REVDEPTH:
+			return p.revdepth;
+		case OSD_REVVOL:
+			return p.revvol;
+		case OSD_REVDELAY:
+			return p.revdelay;
+		case OSD_REVFEEDBACK:
+			return p.revfeedback;
+		case OSD_DISPTIME:
+			return p.displaytime;
+		case OSD_TEMPO:
+			return p.tempo;
+		case OSD_PAUSE:
+			return p.pausestart;
+		//case OSD_SJIS:
+		//	return p.shiftjis;
+		case OSD_REALLOC:
+			return p.realloc;
+		default:
+			return 0;
+	}
+	return 0;
+}
+
+int constrain(int val, int min, int max)
+{
+	if (val > max)
+	{
+		val = max;
+	}
+	if (val < min)
+	{
+		val = min;
+	}
+	return val;
+}
+
+short SetMVolume(short mvol, u_char type)
+{
+	int i;
+	mvol = constrain(mvol, MIN_VOL, MAX_VOL);
+	if (type == MUSIC_NONE)
+	{
+		type = MusicType;
+	}
+	switch (type) {
+		case MUSIC_MOD:
+			if (p.force < 4)
+			{
+				break;
+			}
+		case MUSIC_VAG:
+			for (i = 0; i < seqVoices; i++)
+			{
+				SpuSetVoiceVolume(i, (mvol << 8) + (mvol << 1), (mvol << 8) + (mvol << 1));
+			}
+			break;
+		case MUSIC_XM:
+		case MUSIC_STR:
+		case MUSIC_STR1X:
+		case MUSIC_STR2X:
+		case MUSIC_XA:
+		case MUSIC_XA1X:
+		case MUSIC_XA2X:
+		case MUSIC_DA:
+			//if (p.force)
+			//{
+			p.mvolume = mvol;
+			SetChannels(p.musicChannels, type);
+			//}
+			break;
+		case MUSIC_NEWSEQ:
+			if (p.force)
+			{
+				SsSetMVol(mvol, mvol);
+			}
+			break;
+		default:
+			break;
+	}
+	return mvol;
+}
+
+short SetVolume(short vol, u_char type) {
+	//int voices = 24;
+	//int i;
+	vol = constrain(vol, MIN_VOL, MAX_VOL);
+	if (type == MUSIC_NONE)
+	{
+		type = MusicType;
+	}
+	switch (type) {
+		case MUSIC_VAG:
+		case MUSIC_MOD:
+			p.volume = vol;
+			SetChannels(p.musicChannels, type);
+			break;
+		case MUSIC_XM:
+			if (p.force)
+			{
+				XM_SetMasterVol(Song_ID1, vol);
+			}
+			break;
+		case MUSIC_STR:
+		case MUSIC_STR1X:
+		case MUSIC_STR2X:
+		case MUSIC_XA:
+		case MUSIC_XA1X:
+		case MUSIC_XA2X:
+		case MUSIC_DA:
+			SsSetSerialVol(SS_SERIAL_A, vol, vol);
+			break;
+		case MUSIC_NEWSEQ:
+			SsSeqSetVol(seq1, vol, vol);
+			break;
+		default:
+			break;
+	}
+	return vol;
+}
+
+short SetChannels(short chan, u_char type) {
+	CdlATV	aud;
+	char	result[8];
+	chan = constrain(chan, 0, 4);
+	if (type == MUSIC_NONE)
+	{
+		type = MusicType;
+	}
+	switch (type) {
+		case MUSIC_VAG:
+		case MUSIC_MOD:
+			switch (chan) {
+				case CHANNEL_STEREO:
+				case CHANNEL_REVERSE:
+				case CHANNEL_MONO:
+					SpuSetCommonMasterVolume((p.volume << 7) + p.volume, (p.volume << 7) + p.volume);
+					break;
+				case CHANNEL_LEFT:
+					SpuSetCommonMasterVolume((p.volume << 7) + p.volume, 0);
+					break;
+				case CHANNEL_RIGHT:
+					SpuSetCommonMasterVolume(0, (p.volume << 7) + p.volume);
+					break;
+				default:
+					return p.musicChannels;
+			}
+			break;
+		case MUSIC_XM:
+			switch (chan) {
+				case CHANNEL_STEREO:
+				case CHANNEL_REVERSE:
+					XM_SetStereo();
+					//XM_SetMasterPan(Song_ID1, 0);
+					SpuSetCommonMasterVolume((p.mvolume << 7) + p.mvolume, (p.mvolume << 7) + p.mvolume);
+					break;
+				case CHANNEL_MONO:
+					XM_SetMono();
+					//XM_SetMasterPan(Song_ID1, 0);
+					SpuSetCommonMasterVolume((p.mvolume << 7) + p.mvolume, (p.mvolume << 7) + p.mvolume);
+					break;
+				case CHANNEL_LEFT:
+					XM_SetStereo();
+					//XM_SetMasterPan(Song_ID1, -32000);
+					SpuSetCommonMasterVolume((p.mvolume << 7) + p.mvolume, 0);
+					break;
+				case CHANNEL_RIGHT:
+					XM_SetStereo();
+					//XM_SetMasterPan(Song_ID1, 32000);
+					SpuSetCommonMasterVolume(0, (p.mvolume << 7) + p.mvolume);
+					break;
+				default:
+					return p.musicChannels;
+			}
+			break;
+		case MUSIC_STR:
+		case MUSIC_STR1X:
+		case MUSIC_STR2X:
+		case MUSIC_XA:
+		case MUSIC_XA1X:
+		case MUSIC_XA2X:
+		case MUSIC_NEWSEQ:
+		case MUSIC_DA:
+			switch (chan) {
+				case CHANNEL_STEREO: //Volume managed by SsSetSerialVol
+					aud.val0 = p.mvolume;
+					aud.val1 = 0;
+					aud.val2 = p.mvolume;
+					aud.val3 = 0;
+					SsSetStereo();
+					break;
+				case CHANNEL_MONO:
+					aud.val0 = p.mvolume >> 1;
+					aud.val1 = p.mvolume >> 1;
+					aud.val2 = p.mvolume >> 1;
+					aud.val3 = p.mvolume >> 1;
+					SsSetMono();
+					break;
+				case CHANNEL_LEFT:
+					aud.val0 = p.mvolume;
+					aud.val1 = p.mvolume;
+					aud.val2 = 0;
+					aud.val3 = 0;
+					SsSetStereo();
+					break;
+				case CHANNEL_RIGHT:
+					aud.val0 = 0;
+					aud.val1 = 0;
+					aud.val2 = p.mvolume;
+					aud.val3 = p.mvolume;
+					SsSetStereo();
+					break;
+				case CHANNEL_REVERSE:
+					aud.val0 = 0;
+					aud.val1 = p.mvolume;
+					aud.val2 = 0;
+					aud.val3 = p.mvolume;
+					SsSetStereo();
+					break;	
+				default:
+					return p.musicChannels;
+			}
+			CdControl(CdlDemute, NULL, result);
+			CdControlB(CdlSetfilter, NULL, result);
+			CdMix(&aud);
+			break;
+		default:
+			break;
+	}
+	return chan;
+}
+
+int PlayMusic(EXTENDEDFILEDETAILS file, u_char force_type, char* LongPath)
+{
+	//ParamsV2 pv2; //aligns correctly
+	//printf("first short: %p First char: %p last char: %p last short:% p\n", &pv2.SeqNum, &pv2.rvol, &pv2.mvol, &pv2.tickmode);
+	if (force_type != 0) {
+		file.type = force_type;
+	}
+	UnloadMusic(MusicType);
+	if (MusicType != file.type) {
+		ExitMusic(MusicType);
+		InitMusic(file.type);
+	}
+	LoadMusic(file, LongPath);
+	return 0;
+}
+
+int InitMusic(u_char type)
+{
+	//CdlATV	aud;
+	u_char	result[4] = {CdlModeDA | CdlModeAP, 0, 0, 0}; //CdlModeRept
+
+	switch (type) {
+		case MUSIC_MOD:
+			//ResetCounters();
+			MOD_Init();
+			SetMVolume(p.mvolume, type);
+			SetVolume(p.volume, type);
+			break;
+		case MUSIC_XM:
+		case MUSIC_VAG:
+			libData = 0;
+			/** Common SPU Hardware stuff **/
+			SpuInit();
+			//SpuSetCommonMasterVolume((p.mvolume << 7) + p.mvolume, (p.mvolume << 7) + p.mvolume);
+			SetMVolume(p.mvolume, type);
+			SpuInitMalloc (MALLOC_MAX, spu_malloc_rec);
+			SetAllReverbs(type);
+			break;
+		case MUSIC_XA:
+		case MUSIC_XA1X:
+		case MUSIC_XA2X:
+			songData = malloc3(sizeof(XASECTOR));
+			OldCallback = CdReadyCallback((CdlCB)XACallback);
+		case MUSIC_DA:
+		case MUSIC_STR:
+		case MUSIC_STR1X:
+		case MUSIC_STR2X:
+			CdControlB(CdlDemute, 0, 0);
+		case MUSIC_NEWSEQ:
+			if (type == MUSIC_DA)
+			{
+				CdControlB(CdlSetfilter, 0, 0);
+				CdControlB(CdlSetmode, result, 0);
+			}
+			libData = 0;
+			basepos = 0;
+			basesize = 0;
+			vab1 = 0;
+			SetChannels(p.musicChannels, MusicType);
+
+			SsInit();
+			SsSetTableSize(seq_table, 1, 16);
+			SetTickMode(p.tickmode);
+			SsSetMVol(p.mvolume, p.mvolume);
+
+			SsSetSerialAttr(SS_SERIAL_A, SS_MIX, SS_SON);
+			SsSetSerialAttr(SS_SERIAL_A, SS_REV, SS_SON);
+			SetVolume(type, p.volume);
+			SetAllReverbs(type);
+			break;
+		default:
+			break;
+	}
+	MusicType = type;
+	return 0;
+}
+
+int LoadMusic(EXTENDEDFILEDETAILS file, char* LongPath)
+{
+	u_char* gbuffer;	// CD data loaded to this buffer
+	u_long *cAddress;	// used to get buffer details
+	int result;				// CD read return value
+	CdlLOC fp = {0,0,0,0};				// CD file details
+	int cdloc[2]={0};
+	CdSectorHeader headerDetails;
+	XASECTOR* speedBuf;
+	
+	int XMHeaderSize;
+	int SongSize;
+	
+	StrInfo streamFile;
+	u_char speed;
+	//char UsePXM = 1;
+	char* fname;
+	char* fname2;
+	
+	SpuVoiceAttr voc_attr;
+	u_long events, threads;
+	int i;
+	
+	u_char params[4] = {0,0,0,0};
+	CdlFILTER xafilter;
+	
+	speed = TypeSpeed(file.type);
+
+	
+	switch (file.type) {
+		case MUSIC_MOD:
+			FindFileDetails(&file, LongPath);
+			songData = malloc3(Sectors(file.size) << 11);
+			LoadCdFile(file, songData);
+			seqVoices = ModChannels((u_char*)songData);
+			//printf("Mod loaded with %i channels\n", ModChannels((u_char*)songData));
+			seqMin = 0;
+			seqLength = ((u_char*)songData)[950];
+			MOD_Load((u_char*)songData);
+			MOD_Start();
+			StreamPlaying = 1;
+			break;
+		case MUSIC_XM:
+			FindFileDetails(&file, LongPath);
+			songData = malloc3(Sectors(file.size) << 11);
+			//printf("Sector Size: %i Address of XM: %p\n", Sectors(file.size), songData);
+			LoadCdFile(file, songData);
+			i = 0;
+			//printf("PXM File Count %i PXM File1 Header: %X pBAV: 56414270\n", PXMCount((u_char*)songData), *(u_long*)(PXMFile((u_char*)songData, 0)));
+			if (*songData == 0x004D5850 && PXMCount((u_char*)songData) > 1)
+			{
+				vhData = PXMFile((u_char*)songData, 0);
+				vbData = VBFile(vhData);
+				if (p.realloc)
+				{
+					libData = malloc3(PXMSize((u_char*)songData, 1));
+					memcpy(libData, PXMFile((u_char*)songData, 1), PXMSize((u_char*)songData, 1));
+					xmData = (u_char*)libData;
+				}
+				else
+				{
+					xmData = PXMFile((u_char*)songData, 1);
+				}
+				if (p.force && PXMCount((u_char*)songData) > 2)
+				{
+					LoadParamsV2((ParamsV2*)PXMFile((u_char*)songData, 2));
+				}
+			}
+			else
+			{
+				gbuffer = (u_char*)songData;
+				if (songData[4] == 0x56414270 || songData[4] == 0x70424156)
+				{
+					gbuffer += 16;
+					i = 16;
+					if (p.force)
+					{
+						LoadParamsV2((ParamsV2*)songData);
+					}
+				}
+				vhData = gbuffer;
+				vbData = VBFile(vhData);
+				if (p.realloc)
+				{
+					result = VBSize(gbuffer, 0x65747845, 1);
+					libData = malloc3(file.size - (VHSize(gbuffer) + result + i));
+					memcpy(libData, XMFile(gbuffer, 0x65747845), file.size - (VHSize(gbuffer) + result + i));
+					xmData = (u_char*)libData;
+				}
+				else
+				{
+					xmData = XMFile(gbuffer, 0x65747845);
+				}
+			}
+			XM_OnceOffInit(p.panregion >> 1);	/* NTSC/PAL */
+			SetChannels(p.musicChannels, file.type);				/* or XM_SetMono for mono output */
+	
+			//Allocate buffer for the XM Header and set the address
+			XMHeaderSize = XM_GetFileHeaderSize();
+			XMHeaderAddr = (u_char*)malloc3(XMHeaderSize);
+			XM_SetFileHeaderAddress(XMHeaderAddr);
+	
+			//Allocate buffer for the Song and set the address
+			SongSize = XM_GetSongSize();
+			XMAddr = (u_char*)malloc3(SongSize);
+			XM_SetSongAddress(XMAddr);
+		
+		
+			VABID = XM_VABInit(vhData, vbData);	
+			//Init XM
+			InitXMData(xmData, XM_ID1, p.panregion & 1); /* XM_UseXMPanning/XM_UseS3MPanning */
+			
+			//Read header data
+			Inf = &HInfo;
+			XM_GetHeaderInfo(0, Inf);	/* XM_ID,HeaderInfo structure */
+			
+			//Set callback
+			//VSyncCallback(XM_Update);
+			SetVolume(p.volume, file.type);
+			SetChannels(p.musicChannels, file.type);
+			if (p.realloc)
+			{
+				cAddress = songData;
+				if (*songData == 0x004D5850 && PXMCount((u_char*)songData) > 1)
+				{
+					songData = realloc3(songData, PXMSize((u_char*)songData + songData[2], 1));
+				}
+				else
+				{
+					songData = realloc3(songData, VHSize(gbuffer) + i);
+				}
+				if (songData != cAddress)
+				{
+					printf("WARNING: VAB data moved! (%p to %p)\n", cAddress, songData);
+				}
+			}
+			//Start song
+			Song_ID1=XM_Init(	/* PLAY A SONG */
+				VABID,			/* VAB ID returned from XM_VABInit */
+				XM_ID1,		/* XM ID */
+				0,					/* SongID (-1 to let the player allocate an ID*/
+				0,					/* First Channel to playback on */
+				!p.loops,		/* Looping? */
+				-1,				/* Play bitmask (-1 = all channels playing)*/
+				XM_Music,	/* Music or SFX?*/
+				0					/* Start offset or SFX Pattern */
+			);
+			seqMin = 0;
+			seqVoices = 24;
+			FB = &Feedback;
+			XM_GetFeedback(0, FB);
+			seqLength = Feedback.SongLength;
+			StreamPlaying = 1;
+			break;
+		case MUSIC_VAG:
+			FindFileDetails(&file, LongPath);
+			songData = malloc3(Sectors(file.size) << 11);
+			LoadCdFile(file, songData);
+			seqVoices = 1;
+			
+			SpuSetTransferMode(SpuTransByDMA);
+			events = songData[3];
+			threads = songData[4];
+			seqLength = SWAP_ENDIAN32(threads);
+			//printf("samplerate: %i size: %i\n", SWAP_ENDIAN32(threads), SWAP_ENDIAN32(events));
+			XAChannels = SpuMalloc(SWAP_ENDIAN32(events));
+			SpuSetTransferStartAddr(XAChannels);
+			SpuWrite((u_char*)songData + 48, SWAP_ENDIAN32(events));
+			SpuIsTransferCompleted (SPU_TRANSFER_WAIT);	
+			voc_attr.mask =
+			(
+			  SPU_VOICE_VOLL |
+			  SPU_VOICE_VOLR |
+			  SPU_VOICE_PITCH |
+			  SPU_VOICE_WDSA |
+			  SPU_VOICE_ADSR_AMODE |
+			  SPU_VOICE_ADSR_SMODE |
+			  SPU_VOICE_ADSR_RMODE |
+			  SPU_VOICE_ADSR_AR |
+			  SPU_VOICE_ADSR_DR |
+			  SPU_VOICE_ADSR_SR |
+			  SPU_VOICE_ADSR_RR |
+			  SPU_VOICE_ADSR_SL
+			);
+			voc_attr.voice = SPU_0CH;
+			voc_attr.volume.left = (p.volume << 7) + p.volume;
+			voc_attr.volume.right = (p.volume << 7) + p.volume;
+			if (p.tickmode >= 100 && p.tickmode < 200)
+			{
+				voc_attr.pitch = (((p.tempo * 100) + p.tickmode - 100) << 12) / 44100L;
+			}
+			else
+			{
+				voc_attr.pitch = (SWAP_ENDIAN32(threads) << 12) / 44100L;
+			}
+			voc_attr.addr = XAChannels;
+			voc_attr.a_mode = SPU_VOICE_LINEARIncN;
+			voc_attr.s_mode = SPU_VOICE_LINEARIncN;
+			voc_attr.r_mode = SPU_VOICE_LINEARDecN;
+			voc_attr.ar = 0x0;
+			voc_attr.dr = 0x0;
+			voc_attr.rr = 0x0;
+			voc_attr.sr = 0x0;
+			voc_attr.sl = 0xf;
+			//SetAllReverbs(file.type);
+			SpuSetVoiceAttr(&voc_attr);
+			SpuSetKey(SpuOn,SPU_0CH);
+			SetChannels(p.musicChannels, file.type);
+			if (p.realloc)
+			{
+				cAddress = songData;
+				songData = realloc3(songData, 48);
+				if (songData != cAddress)
+				{
+					printf("WARNING: VAG data moved! (%p to %p)\n", cAddress, songData);
+				}
+			}
+			break;
+		case MUSIC_DA:
+			if (file.basepos)
+			{
+				//printf("DEBUG: Playing track %i then %i mode %i (%s)\n", cdloc[0], cdloc[1], p.loops ? 1 : 2, file.filename);
+				cdloc[0] = file.basepos;
+				CdPlay(p.loops ? 1 : 2, cdloc, 0);
+			}
+			else //if (file.pos)
+			{
+				CdIntToPos(file.pos, &fp);
+				CdControlB(CdlPlay, (u_char*)&fp, 0);
+			}
+			seqMin = file.pos;
+			seqLength = Sectors(file.size);
+			//printf("len: %i pos: %i\n", file.size, file.pos);
+			if (file.size) //file.pos && 
+			{ //track 1 doesn;t work if you don't do this
+				p.endVSync = SectorsToVSyncs(seqLength, 0);
+			}
+			//SetChannels(p.musicChannels, file.type);
+			SetVolume(p.volume, file.type);
+			StreamPlaying = 1;
+			break;
+		case MUSIC_XA:
+		case MUSIC_XA1X:
+		case MUSIC_XA2X:
+			FindFileDetails(&file, LongPath);
+			speedBuf = malloc3(sizeof(XASECTOR) << ((file.basesize != 0xFF && file.basepos != 0xFF) ? 3 : 5));
+			CdIntToPos(file.pos, &fp);
+			if (speed == 0x7F)
+			{
+				speed = XASpeed(fp, speedBuf, 
+				(file.basesize != 0xFF && file.basepos != 0xFF) ? 8 : 32,
+				file.basesize, file.basepos, &file,
+				-(file.basepos == 0xFF), -(file.basesize == 0xFF),
+				(file.basesize != 0xFF && file.basepos != 0xFF) ? 0 : 32, 0);
+			}
+			else if (file.basesize == 0xFF || file.basepos == 0xFF)
+			{
+				XASpeed(fp, speedBuf, 32,
+				file.basesize, file.basepos, &file, -(file.basepos == 0xFF), -(file.basesize == 0xFF), 32, 0);
+			}
+			seqVoices = file.basepos;
+			xafilter.file = file.basesize;
+			xafilter.chan = file.basepos;
+			params[0] = speed|CdlModeRT|CdlModeSF|CdlModeSize1;
+			CdControlF(CdlSetfilter, (u_char*)&xafilter);
+			CdControlB(CdlSetmode, params, 0);
+			CdControlF(CdlReadS, (u_char*)&fp);
+			seqMin = file.pos;
+			seqLength = Sectors(file.size);
+			//printf("len: %i pos: %i\n", file.size, file.pos);
+			if (file.pos && file.size)
+			{
+				p.endVSync = SectorsToVSyncs(seqLength, speed);
+			}
+			SetVolume(p.volume, MusicType);
+			StreamPlaying = 1;
+			free3(speedBuf);
+			break;
+		case MUSIC_STR:
+		case MUSIC_STR1X:
+		case MUSIC_STR2X:
+			gbuffer = malloc3(2340);
+			cAddress = (u_long *)gbuffer;
+			FindFileDetails(&file, LongPath);
+			CdIntToPos(file.pos,&fp);
+			//printf("%i\n", file.pos);
+			while (!CdControlB(CdlSeekL,(unsigned char *)&fp, 0))
+			{
+			  printf("CdlSeekL failed\n");
+			}
+
+			if(!CdRead (1, (unsigned long *)gbuffer,(CdlModeSpeed|CdlModeRT|CdlModeSF|CdlModeSize1)))
+			{
+			  printf("CdRead failed\n");
+			  return -1;
+			}
+
+			// Block until the CD has finished reading
+			do
+			{
+				result = CdReadSync(1,0);
+				if (result < 0)       // error
+				{
+					return -1;
+				}
+			}while (result != 0);
+
+			headerDetails.id=*(unsigned short*)(cAddress+3);
+			headerDetails.type=*( ((unsigned short*)(cAddress+3)+1) );
+
+			cAddress+=4;
+			headerDetails.secCount=*(unsigned short*)(cAddress);
+			headerDetails.nSectors=*( ((unsigned short*)(cAddress)+1) );
+
+			cAddress+=1;
+			headerDetails.frameCount=*(unsigned short *)(cAddress);
+			cAddress+=1;
+			headerDetails.frameSize=*(unsigned short *)(cAddress);
+
+			cAddress+=1;
+			headerDetails.width=*(unsigned short *)(cAddress);
+			headerDetails.height=*( ((unsigned short *)(cAddress)+1) );
+
+			cAddress+=3;
+			headerDetails.reserved=*(unsigned short *)(cAddress);
+
+			//strcpy(streamFile.strName,file.filename);
+			streamFile.strPos = fp;
+			streamFile.mode = p.streamMode;
+			streamFile.drawBorders = p.borders;
+			streamFile.scrWidth = 320;
+			streamFile.x = 0;
+			streamFile.y = 0;
+			streamFile.width = headerDetails.width;
+			streamFile.height = headerDetails.height;
+			streamFile.endFrame = 120000;
+			streamFile.vlcBufSize = 0;
+			streamFile.volume = p.volume;
+			
+			//printf("Stream:%s\n",streamFile.strName);
+			printf("File ID: %i, File Type: %i\n", headerDetails.id, headerDetails.type);
+			printf("Width:%d,Height:%d\n",streamFile.width,streamFile.height);
+			
+			if (speed == 0x7F) {
+				speedBuf = malloc3(sizeof(XASECTOR) << 3);
+				speed = XASpeed(fp, speedBuf, 8, 0xFF, 0xFF, 0, 0, 0, 0, 0);
+				free3(speedBuf);
+				if (!(speed == 0 || speed == CdlModeSpeed)) {
+					//printf("XASPEED FAILED!\n");
+					return -1;
+				}
+			}
+			free3(gbuffer);
+			StreamPlaying = 1;
+			seqLength = Sectors(file.size);
+			seqMin = file.pos;
+			seqSpeed = speed;
+			seqVoices = 0;
+			//SetMVolume(p.mvolume, file.type);
+			PlayStream(&streamFile, file.pos + Sectors(file.size), speed);
+			StreamPlaying = 2;
+			break;
+		case MUSIC_CNF:
+			FindFileDetails(&file, LongPath);
+			songData = malloc3(Sectors(file.size) << 11);
+			LoadCdFile(file, songData);
+			gbuffer = (u_char*)songData;
+			if (p.force >= 5) {
+				for (i = 0; i < file.size; i++) {
+					if (gbuffer[i] > 0x40 && gbuffer[i] < 0x5B) { //isupper
+						gbuffer[i] += 0x20; //tolower
+					}
+				}
+			}
+		case MUSIC_EXE:
+		case MUSIC_NEWEXE:
+		case MUSIC_ZEROEXE:
+			ChangeResMain(4);
+			result = KanjiFntOpen(18, 16, 600, 200, 960, 0, 960, 256, 0, 256);
+			KanjiFntPrint(result, "~p\n\nNow Playing:\n\n%s", file.name); //\t\t\tNow Playing
+			fname = calloc3(24, 1);
+			fname2 = calloc3(((8*8)+15+9), 1);
+			if (file.type == MUSIC_CNF) {
+				if (p.force >= 5) {
+					SplitFilename(fname, fname2, strchr(strstr((char*)songData, "boot"), '='));
+					events = CnfUlong((char*)songData, "event", 10);
+					threads = CnfUlong((char*)songData, "tcb", 10);
+					file.basepos = (int)CnfUlong((char*)songData, "stack", 16);
+				} else {
+					SplitFilename(fname, fname2, strchr(strstr((char*)songData, "BOOT"), '='));
+					events = CnfUlong((char*)songData, "EVENT", 10);
+					threads = CnfUlong((char*)songData, "TCB", 10);
+					file.basepos = (int)CnfUlong((char*)songData, "STACK", 16);
+				}
+			} else if (LongPath) {
+				FindFileDetails(&file, LongPath);
+				SplitFilename(fname, fname2, LongPath);
+			} else {
+				sprintf(fname2, "cdrom:%s", currentPath);
+				sprintf(fname, "cdrom:%s", file.name);
+			}
+			if (file.type == MUSIC_NEWEXE || file.type == MUSIC_ZEROEXE) { //Using 0 for stack will use default stack
+				FindFileDetails(&file, LongPath);
+				file.size = 2048;
+				libData = malloc3(2048);
+				LoadCdFile(file, libData);
+				file.basepos = (int)libData[12];
+				if (file.type == MUSIC_ZEROEXE) {
+					file.basesize = 0;
+				} else {
+					file.basesize = (int)libData[13];
+				}
+				printf("Stack Addr: %X Stack Size: %X\nExe Text: %s\n", file.basepos, file.basesize, (char*)(libData + 19));
+				free3(libData);
+			}
+			//printf("Loading EXE from %s\n", fname2);
+			DrawSync(0);
+			KanjiFntFlush(result);
+			//VSync(0);
+			PutEnvs();
+			//dont need to remove anything here since it gets deleted anyway
+			ResetGraph(3);
+			PadStop();
+			StopCallback();
+			if (file.type == MUSIC_CNF) {
+				SetConf(events, threads, (u_long)file.basepos);
+			}
+			_96_init();
+			cd(fname2);
+			/* need _96_init(), because open() & read() are called in LoadExec(). */
+			//printf("LoadExec:%s\n",fname);
+			/* child's stack pointer = STACKP2 */
+			LoadExec(fname, file.basepos, file.basesize);
+			//_96_remove();
+			printf("Back From EXE Somehow\n");
+			free3(fname);
+			free3(fname2);
+			if (file.type == MUSIC_CNF)
+			{
+				free3(songData);
+			}
+			break;
+		case MUSIC_NEWSEQ:
+			FindFileDetails(&file, LongPath);
+			songData = malloc3(Sectors(file.size) << 11);
+			LoadCdFile(file, songData);
+			//song data has to be loeded first for some reason
+			//sadly it wastes some memory that way
+			result = file.size;
+			if (file.basepos != basepos || file.basesize != basesize)
+			{
+				if (libData) //LIBDATA MUST BE SET TO 0!
+				{
+					free3(libData);
+				}
+				file.pos = file.basepos;
+				file.size = file.basesize;
+				libData = malloc3(Sectors(file.basesize) << 11);
+				LoadCdFile(file, libData); //This should be separeted into VH and VB in memory.
+				basepos = file.basepos; //Read first sector from file to check size, then VH and VB.
+				basesize = file.basesize; //Do it for XM VAB too when you do this. ignore this realloc3/memcpy work better
+				if (vab1 > -1)
+				{
+					SsVabClose(vab1);
+				}
+				vab1 = SsVabTransfer((u_char*)libData, VBFile((u_char*)libData), -1, SS_WAIT_COMPLETED);
+			}
+			//vh1 = SsVabOpenHead((u_char*)libData, -1);
+			//vb1 = SsVabTransBody(VBFile((u_char*)libData), vh1);
+			//SsVabTransCompleted(SS_WAIT_COMPLETED);
+			//vab1 = SsVabTransfer((u_char*)libData, VBFile((u_char*)libData), -1, SS_WAIT_COMPLETED);
+			if (p.realloc)
+			{
+				cAddress = libData;
+				libData = realloc3(libData, VHSize((u_char*)libData));
+				if (libData != cAddress)
+				{
+					printf("WARNING: VAB data moved! (%p to %p)\n", cAddress, libData);
+				}
+			}
+			//printf("VAB %i: %p\n", vab1, libData);
+			SsStart2();
+			if (*songData == 0x004D5850 && PXMCount((u_char*)songData) > 0) 
+			{
+				seqLength = PXMSize((u_char*)songData, 0);
+				seqMin = (int)PXMFile((u_char*)songData, 0);
+				seq1 = SsSeqOpen((u_long*)PXMFile((u_char*)songData, 0), vab1);
+				if (p.force && PXMCount((u_char*)songData) > 1)
+				{
+					LoadParamsV2((ParamsV2*)PXMFile((u_char*)songData, 1));
+				}
+			}
+			else
+			{
+				gbuffer = (u_char*)songData;
+				speed = 0;
+				if (songData[4] == 0x53455170 || songData[4] == 0x70514553)
+				{
+					gbuffer += 16;
+					result -= 16;
+					speed = 16;
+				}
+				seqLength = result;
+				seqMin = (int)gbuffer;
+				seq1 = SsSeqOpen((u_long*)gbuffer, vab1);
+				if (speed && p.force)
+				{
+					LoadParamsV2((ParamsV2*)songData);
+				}
+			}
+			seqVoices = 0;
+			//free3(libData); //Remove VAB from main memory since it's in sound RAM
+			//libData = 0; //Not removed since the VH still has to be in memory. The VB can be removed. 
+			//SsSetMVol (p.mvolume, p.mvolume);
+			speed = 0;
+			SsSeqSetVol (seq1, p.volume, p.volume);
+			StreamPlaying = 1;
+			SsSeqPlay(seq1, SSPLAY_PLAY, p.loops);
+			break;
+		default:
+			break;
+	}
+	p.vsyncBase = VSync(-1);
+	p.vsyncPauseBase = 0;
+	seqSpeed = speed;
+	if (p.pausestart && StreamPlaying == 1)
+	{
+		PlayPauseMusic(file.type);
+	}
+	return 0;
+}
+
+int UnloadMusic(u_char type) 
+{
+	int loc[2] = {0};
+	if (type == MUSIC_NONE)
+	{
+		type = MusicType;
+	}
+	switch (type) {
+		case MUSIC_MOD:
+			MOD_Stop();
+			MOD_Free();
+			free3(songData);
+			StreamPlaying = 0;
+			break;
+		case MUSIC_XM:
+			if (libData)
+			{
+				free3(libData);
+				libData = 0;
+			}
+			XM_Exit();							// STOP TUNE PLAYING
+			XM_FreeAllSongIDs();				// FREE SONG ID's
+			XM_FreeAllFileHeaderIDs();		// FREE HEADER ID's
+			
+			free3(XMHeaderAddr);
+			free3(XMAddr);
+			free3(songData);
+			StreamPlaying = 0;
+			break;
+		case MUSIC_VAG:
+			SpuSetKey(SpuOff,SPU_0CH);
+			SpuFree(XAChannels);
+			free3(songData);
+			break;
+		case MUSIC_DA:
+			CdPlay(0, loc, 0);
+			StreamPlaying = 0;
+			break;
+		case MUSIC_XA:
+		case MUSIC_XA1X:
+		case MUSIC_XA2X:
+			CdControlB(CdlPause, 0, 0);
+			break;
+		case MUSIC_NEWSEQ:
+			SsSeqClose (seq1);
+			//SsVabClose (vab1);
+			free3(songData);
+			//seqLength = 0;
+			StreamPlaying = 0;
+			break;
+		default:
+			break;
+	}
+	seqMin = 0;
+	seqLength = 0;
+	seqSpeed = 0;
+	seqVoices = 0;
+	p.vsyncBase = 0;
+	p.vsyncPauseBase = 0;
+	p.endVSync = 0;
+	return 0;
+}
+
+int ExitMusic(u_char type) 
+{
+	u_char param[4] = {CdlModeSpeed, 0, 0, 0};
+	if (type == MUSIC_NONE)
+	{
+		type = MusicType;
+	}
+	switch (type) {
+		case MUSIC_MOD:
+			//VSyncCallback((void (*)()) VSyncCB);
+			//VSync(75);
+			break;
+		case MUSIC_XM:
+		case MUSIC_VAG:
+			SpuClearReverbWorkArea(p.revmode);
+			SpuSetReverb(SPU_OFF);
+			SpuQuit();
+			break;
+		case MUSIC_XA: //need to do case fallthrough
+		case MUSIC_XA1X:
+		case MUSIC_XA2X:
+			CdControlB(CdlPause, 0, 0);
+			CdReadyCallback((void*)OldCallback);
+			free3(songData);
+		case MUSIC_DA:
+			CdControl(CdlSetmode, param, 0);
+		case MUSIC_STR:
+		case MUSIC_STR1X:
+		case MUSIC_STR2X:
+		case MUSIC_NEWSEQ:
+			if (vab1 > -1)
+			{
+				SsVabClose(vab1);
+			}
+		    SsUtReverbOff();
+			//SsUtSetReverbType(0);
+			//SsUtSetReverbDepth(0,0);
+			SpuClearReverbWorkArea(p.revmode);
+			// Clear last 100K of SPU RAM (i.e. maximum reverb workarea). 
+
+
+			// Wait until SPU RAM cleared.
+			//VSync(100);
+			//Need to think about how to turn off reverb when switching song types
+			SsEnd();
+			SsQuit();
+			/*
+			SpuInit();
+			SpuSetTransStartAddr(421887);
+			SpuWrite0(1024 * 100); //im pretty sure this isnt async
+			SpuQuit();
+			*/
+			if (libData)
+			{
+				free3(libData);
+				libData = 0;
+			}
+			break;
+		default:
+			break;
+	}
+	MusicType = MUSIC_NONE;
+	return 0;
+}
+
+int SeekMusic(u_char type, short absolute, int pos, int min, int max, int seconds, int minutes, u_char speed)
+{
+	u_char param[4] = {0};
+	u_char result[8] = {0};
+	int cdpos = 0;
+	int patpos = 0;
+	if (type == MUSIC_NONE)
+	{
+		type = MusicType;
+	}
+	switch (type) {
+		case MUSIC_MOD:
+			if (absolute)
+			{
+				cdpos = min;
+				patpos = 0;
+			}
+			else
+			{
+				cdpos = min + *MOD_CurrentOrder;
+				patpos = 0 + *MOD_CurrentRow;
+				if (!minutes)
+				{
+					pos = 0;
+					patpos = 0;
+				}
+			}
+			*MOD_CurrentOrder = constrain(cdpos + seconds, min, max - 1);
+			if (minutes > 1000)
+			{
+				*MOD_CurrentPattern = minutes - 1000;
+			}
+			else
+			{
+				*MOD_CurrentPattern = ((u_char*)songData)[952 + *MOD_CurrentOrder];
+			}
+			*MOD_CurrentRow = constrain(patpos + pos, 0, 63);
+			break;
+		case MUSIC_XM:
+			//XMPLAY can't change rows so looking at the format spec isn't needed
+			if (absolute)
+			{
+				cdpos = min;
+			}
+			else
+			{
+				cdpos = min + CurrentTime(type);//-1?
+			}
+			XM_SetSongPos(0, constrain(cdpos + seconds, min, max - 1));
+			break;
+		case MUSIC_STR:
+		case MUSIC_STR1X:
+		case MUSIC_STR2X:
+		case MUSIC_XA: //this probably works
+		case MUSIC_XA1X:
+		case MUSIC_XA2X:
+		case MUSIC_DA:
+			//CdControlB(CdlPause, 0, 0); //not needed? if it is then convert vsyncs into sectors. make sure to check if its getlocp or reads that causes issue
+			if (!absolute)
+			{
+				CdControl(CdlGetlocP, param, result);
+				param[0] = result[5];
+				param[1] = result[6];
+				param[2] = result[7];
+				param[3] = result[0];
+				cdpos = CdPosToInt((CdlLOC*)&param);
+			}
+			else
+			{
+				cdpos = min;
+			}
+			pos += seconds * 75;
+			pos += minutes * 4500;
+			if (speed) {
+				pos <<= 1;
+			}
+			//printf("Old Sector: %i ", cdpos - min);
+			if (cdpos + pos > max) {
+				CdIntToPos(max, (CdlLOC*)&param);
+				cdpos = max;
+			} else if (cdpos + pos < min) {
+				CdIntToPos(min, (CdlLOC*)&param);
+				cdpos = min;
+			} else {
+				CdIntToPos(cdpos + pos, (CdlLOC*)&param);
+				cdpos += pos;
+			}
+			if (StreamPlaying) {
+				if (type == MUSIC_DA)
+				{
+					CdControl(CdlPlay, param, result);
+				}
+				else
+				{
+					CdControl(CdlReadS, param, result);	
+				}
+			} else {
+				CdControl(CdlSetloc, param, result);
+				CdControlB(CdlSeekP, param, result);	
+			}
+			p.vsyncBase = VSyncGetCurrent() - SectorsToVSyncs(cdpos - min, speed);
+			break;
+		case MUSIC_NEWSEQ:
+			if (absolute)
+			{
+				cdpos = min;
+			}
+			else
+			{
+				cdpos = (int)SsGetCurrentPoint(seq1, 0);
+			}
+			pos += seconds << 4; //16
+			pos += minutes << 10; //1024
+			cdpos = constrain((int)((u_char*)cdpos + pos), min, max - 16);
+			SsSetCurrentPoint(seq1, 0, (u_char*)cdpos);
+			break;
+		default:
+			break;
+	}
+	//printf("New Sector: %i\n", cdpos - min);
+	return cdpos - min; //Use this for video OSD clock
+	//((cdpos - min) * 75 * SPEED) / VSYNC_NTSC OR VSYNC_PAL
+}
+
+int PlayPauseMusic (u_char type)
+{
+	u_char param[4] = {0};
+	u_char result[8] = {0};
+	//printf("Stream State: %i\n", StreamPlaying);
+	/*
+	if (p.vsyncPauseBase) {
+		p.vsyncBase += VSync(-1) - p.vsyncPauseBase;
+		p.vsyncPauseBase = 0;
+	} else {
+		p.vsyncPauseBase = VSync(-1);
+	}
+	*/
+	if (type == MUSIC_NONE)
+	{
+		type = MusicType;
+	}
+	switch (StreamPlaying) {
+		case 0:
+			p.vsyncBase += VSync(-1) - p.vsyncPauseBase;
+			p.vsyncPauseBase = 0;
+		//case 2:
+			switch (type) {
+				case MUSIC_MOD:
+					MOD_Start();
+					break;
+				case MUSIC_XM:
+					XM_Restart(Song_ID1);
+					break;
+				case MUSIC_DA:
+					CdControl(CdlGetlocP, param, result);
+					param[0] = result[5];
+					param[1] = result[6];
+					param[2] = result[7];
+					param[3] = result[0];
+					CdControl(CdlPlay, param, result);
+					break;
+				case MUSIC_STR:
+				case MUSIC_STR1X:
+				case MUSIC_STR2X:
+				case MUSIC_XA:
+				case MUSIC_XA1X:
+				case MUSIC_XA2X:
+					CdControl(CdlGetlocP, param, result);
+					param[0] = result[5];
+					param[1] = result[6];
+					param[2] = result[7];
+					param[3] = result[0];
+					CdControl(CdlReadS, param, result);
+					break;
+				case MUSIC_NEWSEQ:
+					SsSeqReplay(seq1);
+					break;
+				default:
+					break;
+			}
+			StreamPlaying = 1;
+			break;
+		case 1:
+			p.vsyncPauseBase = VSync(-1);
+			switch (type) {
+				case MUSIC_MOD:
+					MOD_Stop();
+					break;
+				case MUSIC_XM:
+					XM_Pause(Song_ID1);
+					break;
+				case MUSIC_STR:
+				case MUSIC_STR1X:
+				case MUSIC_STR2X:
+				case MUSIC_XA:
+				case MUSIC_XA1X:
+				case MUSIC_XA2X:
+				case MUSIC_DA:
+					CdControlB(CdlPause, 0, 0);
+					break;
+				case MUSIC_NEWSEQ:
+					SsSeqPause(seq1);
+					break;
+				default:
+					break;
+			}
+			StreamPlaying = 0;
+			break;
+		case 2:
+			break;
+		default:
+			StreamPlaying = 1;
+			break;
+	}
+	return 0;
+}
+
+int PXMCount(u_char* ptr)
+{
+	return *(int*)(ptr + 4);
+}
+
+u_char* PXMFile(u_char* ptr, int file)
+{
+	return ptr + *(int*)(ptr + 8 + (file << 3));
+}
+
+int PXMSize(u_char* ptr, int file)
+{
+	//printf("PSX SIZE FILE %i: %i\n", file, *(int*)(ptr + 12 + (file << 3)));
+	return *(int*)(ptr + 12 + (file << 3));
+}
+
+int VHSize(u_char* ptr)
+{
+	return 0xA20 + ((*(short*)(ptr + 0x12)) << 9);
+}
+
+int VBSize(u_char* ptr, u_long magic, char use_magic)
+{
+	int i;
+	int xm = 0;
+	u_short* vag;
+	//printf("Header VAB Size: %i\n", *(u_long*)(ptr + 12));
+	if (use_magic & 2 || (use_magic & 1 && *(u_long*)(ptr + *(u_long*)(ptr + 12)) == magic))
+	{
+		return *(int*)(ptr + 12) - VHSize(ptr);
+	}
+	vag = (u_short*)(VBFile(ptr) - 0x200);
+	for (i = 1; i <= *(u_short*)(ptr + 22); i++)
+	{
+		xm += vag[i] << 3;
+		//printf("VAG %i Size: %i\n", i, vag[i] << 3);
+	}
+	//printf("Total VAB Size: %i Signature/Target:%X/%X\n", xm + 0xA20 + ((*(short*)(ptr + 0x12)) << 9), *(u_long*)(VBFile(ptr) + xm), magic);
+	return xm;
+}
+
+u_char* VBFile(u_char* ptr)
+{
+	return ptr + VHSize(ptr);
+}
+
+u_char* XMFile(u_char* ptr, u_long magic)
+{
+	return VBFile(ptr) + VBSize(ptr, 0x65747845, 1);
+}
+
+int ModChannels(u_char* ptr)
+{
+	if (ptr[1082] != 0x54)
+	{
+		return ((ptr[1082] - 0x30) * 10) + ptr[1083] - 0x30; //HM10-16
+	}
+	return ptr[1083] - 0x30; //HIT1-9
+}
+
+u_char XASpeed(CdlLOC fp, XASECTOR* buf, int sect, u_char file, u_char channel, EXTENDEDFILEDETAILS* menu, int nmax, int flen, int sectmin, u_char buf_full) {
+	int first_pos = -1, second_pos = -1;
+	int base_inter = 8; //8, single speed since all zeroes is mono 37.8 4bit
+	int sectcount = 0;
+	//int sectmin = 0;
+	int i;
+	int n = 2;
+	u_char mtype;
+	XASECTOR* oldbuf = buf;
+	CdlLOC mfp = fp;
+	XAChannels = 0;
+	//oldbuf = buf;
+	//short septrk = 0;
+	//printf("sects:%i, file:%X channel:%X, xachans (no channel):%i xalen (no file):%i, searchsects:%i\n", sect, file, channel, nmax, flen, sectmin);
+	//if (!buf) {buf=malloc3(sizeof(XASECTOR) * sect);} //also need free3 and include
+	if (menu)
+	{
+		mtype = file;
+		file = 0xFF;
+	}
+	while (sectcount < sectmin || second_pos == -1) {
+		//printf("made it back, %i buffers\n", buf_full);
+		if (!buf_full)
+		{
+			//printf("no buffer, reading cd from %i\n", CdPosToInt(&fp));
+			//printf("BUFFER: %p OLD BUFFER: %p\n", buf, oldbuf);
+			buf = oldbuf;
+			CdControlB(CdlSetloc, (u_char*)&fp, 0);
+			CdRead(sect, (u_long*)buf, CdlModeSpeed|CdlModeSize1);
+			CdReadSync(0, 0);
+			//printf("got cd\n");
+		}
+		else
+		{
+			buf_full--;
+			//printf("buffer now %i (%i sectors) remaining\n", buf_full, buf_full * sect);
+		}
+		for (i = 0; i < sect; i++) {
+			//if (buf[i].channel > septrk) {
+			//	septrk = buf[i].channel;
+			//
+			//printf("s:%i %i\n", sectcount, i);
+			if (buf[i].submode & 0x04) { //AUDIO BIT
+				if (nmax >= 0 && menu && !(XAChannels & (1 << buf[i].channel)))
+				{
+					if (nmax && n >= nmax) //menu && n > nmax
+					{
+						printf("Too many XA files! (%i)\n", n);
+					}
+					else
+					{
+						menu[n].type = mtype;
+						menu[n].pos = CdPosToInt(&mfp);
+						menu[n].size = flen;
+						menu[n].basepos = buf[i].channel;
+						menu[n].basesize = buf[i].file;
+						sprintf(menu[n].name, "XA Channel %i", buf[i].channel);
+					}
+					n++;
+				}
+				XAChannels |= (1 << buf[i].channel);
+				if (channel == 0xFF) { //only set file/channel after finding an audio track
+					channel = buf[i].channel;
+				}
+				if (buf[i].channel == channel && file == 0xFF) { //Videos use multiple files per channel
+					file = buf[i].file;
+				}
+				if (buf[i].file == file && buf[i].channel == channel) {
+					if (first_pos == -1) {
+						first_pos = sectcount;
+						if (buf[i].code & 0x01) { //STEREO
+							base_inter >>= 1;
+						}
+						if (buf[i].code & 0x04) { //18.9 KHZ
+							base_inter <<= 1;
+						}
+						if (p.force >= 4 && buf[i].code & 0x10) { //8 BIT (ALMOST NEVER USED)
+							//#if DEBUG
+								printf("File has 8 bit audio!\n");
+							//#endif
+							base_inter >>= 1; //normally this is a disc error
+						}
+					} else if (second_pos == -1) {
+						second_pos = sectcount;
+						break;
+					}
+				}
+			}
+			sectcount++;
+		}
+		if (sectcount >= 1000) {
+			printf("Couldn't detect XA speed\n");
+			return -2;
+		}
+		CdIntToPos(CdPosToInt(&fp) + sect, &fp);
+		buf += sect;
+	}
+	//septrk++;
+	printf("XA: %X\n", XAChannels);
+	#if DEBUG
+		printf("1X Sector Gap: %i, 2X Sector Gap:%i, Channels: %X\n", base_inter, base_inter * 2, XAChannels);
+		printf("First Position: %i Second Position: %i, Interval: %i\n", first_pos, second_pos, second_pos - first_pos);
+	#endif
+	if (menu)
+	{
+		if (nmax < 0)
+		{
+			menu->basepos = channel;
+		}
+		if (flen < 0)
+		{
+			menu->basesize = file;
+		}
+	}
+	if (second_pos - first_pos == base_inter) {
+		return 0;
+	}
+	if (second_pos - first_pos == base_inter << 1) {
+		return CdlModeSpeed;
+	}
+	return -1;
+}
+
+u_char TypeSpeed(u_char type) {
+	switch (type)
+	{
+		case MUSIC_DA:
+		case MUSIC_STR1X:
+		case MUSIC_XA1X:
+			return 0;
+		case MUSIC_STR2X:
+		case MUSIC_XA2X:
+			return CdlModeSpeed;
+		default:
+			return 0x7F;
+	}
+}
+char* SplitFilename (char* fname, char* fname2, char* fname0) { //loadexec works with or without semicolon
+	char* fname5;
+	char* fname3;
+	int fname4;
+	char fname1;
+	fname3 = strstr(fname0, "cdrom:");
+	fname4 = strcspn(fname3, " \r\n");
+	fname1 = fname3[fname4];
+	fname3[fname4] = 0;
+	fname5 = strrchr(fname3, '\\');
+	if (!fname5) {
+		fname5 = strrchr(fname3, ':');
+	}
+	if (!fname5) {
+		strcpy(fname, fname3);
+		strcpy(fname2, "cdrom:\\");
+		fname3[fname4] = fname1;
+		return fname3;
+	}
+	sprintf(fname, "cdrom:%s", fname5 + 1);
+	fname3[fname4] = fname1;
+	fname1 = *fname5;
+	*fname5 = 0;
+	if (strchr(fname3, '\\')) {
+		sprintf(fname2, "%s", fname3);
+	} else if (strchr(fname3, ':')) {
+		sprintf(fname2, "%s\\", fname3);
+	} else {
+		sprintf(fname2, "%s:\\", fname3);
+	}
+	*fname5 = fname1;
+	return fname3;
+}
+
+u_long CnfUlong (char* cnf, char* entry, int base)
+{
+	return strtoul(strchr(strstr(cnf, entry), '=') + 1, 0, base);
+}
+
+int CurrentTime(u_char type)
+{
+	if (type == MUSIC_NONE)
+	{
+		type = MusicType;
+	}
+	switch (type)
+	{
+		case MUSIC_NEWSEQ:
+			return (int)(SsGetCurrentPoint(seq1, 0) - (u_char*)seqMin);
+		case MUSIC_XM:
+			XM_GetFeedback(0, FB);
+			return Feedback.SongPos;
+		case MUSIC_MOD:
+			return *MOD_CurrentOrder;
+	}
+	return 0;
+}
+
+short SetTickMode(short mode)
+{
+	switch (mode)
+	{
+		case SS_NOTICK0:
+		case SS_NOTICK:
+			if ((p.force >= 3 && *(char *)0xbfc7ff52!='E') || p.force >= 5)
+			{
+				SsSetTickMode(mode);
+			}
+			else if (*(char *)0xbfc7ff52=='E')
+			{
+				SsSetTickMode(100);
+				return 100;
+			}
+			else
+			{
+				SsSetTickMode(SS_TICK120);
+				return SS_TICK120;
+			}
+		case 50:
+		case SS_TICK50:
+			if (*(char *)0xbfc7ff52!='E' || p.force >= 5)
+			{
+				SsSetTickMode(mode);
+			}
+			else
+			{
+				SsSetTickMode(100);
+				return 100;
+			}
+			break;
+		case 60:
+		case SS_TICK60:
+			if (*(char *)0xbfc7ff52=='E' || p.force >= 5)
+			{
+				SsSetTickMode(mode);
+			}
+			else
+			{
+				SsSetTickMode(SS_TICK120);
+				return SS_TICK120;
+			}
+			break;
+		case SS_TICKVSYNC:
+			if (p.force >= 5)
+			{
+				SsSetTickMode(mode);
+			}
+			else if (*(char *)0xbfc7ff52=='E')
+			{
+				SsSetTickMode(100);
+				return 100;
+			}
+			else
+			{
+				SsSetTickMode(SS_TICK120);
+				return SS_TICK120;
+			}
+			break;
+		default:
+			//if (p.force)
+			//{
+			SsSetTickMode(mode);
+			//}
+			break;
+	}
+	return mode;
+}
+
+void SetAllReverbs(u_char type)
+{
+	if (type == MUSIC_NONE)
+	{
+		type = MusicType;
+	}
+	SetReverb(p.revmode, p.revdepth, type);
+	SetReverbVolume(p.revvol, type);
+	SetReverbDelay(p.revdelay, type);
+	SetReverbFeedback(p.revfeedback, type);
+	return;
+}
+
+void CdStopMusic(u_char type)
+{
+	if (type == MUSIC_NONE)
+	{
+		type = MusicType;
+	}
+	switch (type)
+	{
+		case MUSIC_STR:
+		case MUSIC_STR1X:
+		case MUSIC_STR2X:
+		case MUSIC_XA:
+		case MUSIC_XA1X:
+		case MUSIC_XA2X:
+		case MUSIC_DA:
+			UnloadMusic(type);
+			ExitMusic(type);
+			break;
+	}
+	return;
+}
+
+void LoadParamsV2(ParamsV2* params)
+{
+	//printf("seqnum: %i version: %i\n", params->SeqNum, params->Version);
+	if (params->Version != 2 && p.force < 5)
+	{
+		return;
+	}
+	//printf("rev - mode: %i vol: %i depth: %i delay: %i feedback: %i\n", params->rtype, params->rvol, params->rdepth, params->rdelay, params->rfeedback);
+	if (p.force >= 1)
+	{
+		if (params->rtype != 0xFF || p.force >= 5) //FFF0 is for errors with integer division (combined L and R)
+		{
+			p.revmode = constrain(params->rtype, 0, 9);
+		}
+		if (params->rvol != 0xFF || p.force >= 5)
+		{
+			p.revvol = constrain(params->rvol, 0, 127);
+		}
+		if (params->rdepth != 0xFF || p.force >= 5)
+		{
+			p.revdepth = constrain(params->rdepth, 0, 127);
+		}
+		if (params->rdelay != 0xFF || p.force >= 5)
+		{
+			p.revdelay = constrain(params->rdelay, 0, 127);
+		}
+		if (params->rfeedback != 0xFF || p.force >= 5)
+		{
+			p.revfeedback = constrain(params->rfeedback, 0, 127);
+		}
+		SetAllReverbs(MusicType);
+		if (params->mvol != 0xFF || p.force >= 5)
+		{
+			p.mvolume = SetMVolume(params->mvol, MusicType);
+		}
+		if (params->loops != 0xFFFF || p.force >= 5)
+		{
+			p.loops = params->loops;
+		}
+	}
+	if (p.force >= 2 && (params->vol != 0xFF || p.force >= 5))
+	{
+		p.volume = SetVolume(params->vol, MusicType);
+	}
+	if (p.force >= 3 && (params->tickmode != 0xFFFF || p.force >= 5) && MusicType == MUSIC_NEWSEQ)
+	{
+		p.tickmode = SetTickMode(params->tickmode);
+	}
+	if (p.force >= 4) //4
+	{
+		p.musicChannels = SetChannels(params->reserved & 15, MusicType); //if it's F automatically does nothing
+	}
+	if (p.force >= 5 && (params->reserved & 0xF0 != 0xF0))
+	{
+		p.panregion = params->reserved >> 4;
+	}
+	//printf("loops: %i mvol: %i   vol: %i tickmode: %i etc:%X\n", params->loops, params->mvol, params->vol, params->tickmode, params->reserved);
+	return;
+}
+
+short SetTempo(short tempo, u_char type)
+{
+	if (type == MUSIC_NONE)
+	{
+		type = MusicType;
+	}
+	tempo = constrain(tempo, 1, 9999);
+	switch (type)
+	{
+		case MUSIC_NEWSEQ:
+			SsSetTempo(seq1, 0, tempo);
+			break;
+		case MUSIC_XM:
+			XM_SetBPM(Song_ID1, tempo);
+			break;
+		default:
+			MusicAdjust(tempo, p.tickmode);
+			break;
+	}
+	return tempo;
+}
+
+void XACallback(int intr, u_char *result)
+{
+	//XASECTOR cbbuf;
+	int ID, currentChannel;
+	u_long *cAddress=songData;
+	if (intr == CdlDataReady)
+	{
+		CdGetSector(songData,8);
+		ID = *(unsigned short *)(cAddress+3);
+		currentChannel = *((unsigned short *)(cAddress+3)+1);
+		currentChannel = (currentChannel&31744)>>10;
+		if( (ID == 352) && (currentChannel == seqVoices) )
+		{
+		    UnloadMusic(MusicType);
+		    StreamPlaying = 2;
+		}
+	}
+	else
+		printf("UnHandled Callback Occured\n");
+}
\ No newline at end of file
diff --git a/music.h b/music.h
new file mode 100644
index 0000000..e527335
--- /dev/null
+++ b/music.h
@@ -0,0 +1,254 @@
+/**** Initialise SPU data ****/
+
+#define MALLOC_MAX 128
+char spu_malloc_rec [SPU_MALLOC_RECSIZ * (MALLOC_MAX + 1)];
+
+/**** FEEDBACK SCRUCTURES ****/
+XM_Feedback Feedback;
+XM_Feedback *FB;
+XM_HeaderInfo HInfo;
+XM_HeaderInfo *Inf;
+XM_VABInfo VInfo;
+XM_VABInfo *VInf;
+
+//XM Stuff
+#define XM_ID1 0
+
+#define SWAP_ENDIAN32(x) (((x)>>24) | (((x)>>8) & 0xFF00) | (((x)<<8) & 0x00FF0000) | ((x)<<24))
+
+typedef struct {
+	u_char sector[3];
+	u_char mode;
+	u_char file;
+	u_char channel;
+	u_char submode;
+	u_char code;
+	u_char file_b;
+	u_char channel_b;
+	u_char submode_b;
+	u_char code_b;
+	u_char data[2324];
+	int DUMMY;
+} XASECTOR;
+
+typedef struct {
+	u_short SeqNum;
+	u_short Version;
+	u_short loops;
+	u_char rvol;
+	u_char rdepth;
+	u_char rdelay;
+	u_char rtype;
+	u_char rfeedback;
+	u_char reserved;
+	u_char vol;
+	u_char mvol;
+	u_short tickmode;
+} ParamsV2;
+
+typedef struct {
+	char name[64];
+	int	size;
+	int	addr;
+	int	sector_size;
+	int	byte_addr;
+	u_long stack;
+} VFSFILE;
+
+typedef struct 
+{
+	char name[96];
+}
+FULLFILENAME;
+
+typedef struct {
+	int	vsyncBase;
+	int endVSync;
+	int vsyncPauseBase; //Set this to corrent vsync when paused.
+	short streamMode; //STR_MODE24
+	short borders; //STR_BORDERS_ON
+	short volume; //127 MAX_VOL
+	short musicChannels;
+	short mvolume;
+	short force;
+	short panregion;
+	short tickmode;
+	short loops;
+	short minutes;
+	short seconds;
+	short frames;
+	short inputspeed;
+	short repeatspeed;
+	short seekminutes;
+	short seekseconds;
+	short seekframes;
+	short revmode;
+	short revvol;
+	short revdepth;
+	short revdelay;
+	short revfeedback;
+	short displaytime;
+	short tempo;
+	char pausestart;
+	//char shiftjis;
+	char realloc;
+} ParamsShared;
+
+//Common Music
+
+#define MUSIC_NONE 0x00
+#define MUSIC_MOD 0x01
+#define MUSIC_XM 0x02
+#define MUSIC_SEQ 0x03
+#define MUSIC_SEP 0x04
+#define MUSIC_VAG 0x05
+#define MUSIC_XA 0x06
+#define MUSIC_DA 0x07
+#define MUSIC_TIM 0x08
+#define MUSIC_EXE 0x09
+#define MUSIC_STR 0x0A
+#define MUSIC_STR1X 0x0B
+#define MUSIC_STR2X 0x0C
+#define MUSIC_XA1X 0x0D
+#define MUSIC_XA2X 0x0E
+#define MUSIC_VAB 0x0F
+#define MUSIC_NEWSEQ 0x10
+#define MUSIC_SEQONLY 0x11
+#define MUSIC_PARAMS 0x12
+#define MUSIC_NEWEXE 0x13 //load stack+size from file
+#define MUSIC_ZEROEXE 0x14 //load stack, not size from file
+#define MUSIC_ALLPARAMS 0x15 //not really needed since OSD works well enough
+//#define MUSIC_SEQALLPARAMS 0x15 //not needed to to settings
+#define MUSIC_CNF 0x16
+#define MUSIC_CNFNEW 0x17 //Loads various files from disc, replaces all the commented out stuff below.
+/*
+#define MUSIC_VAB_DISC 0x17 //load vh/vb from disc into memory from file
+#define MUSIC_SEQ_DISC 0x18 //load seq from disc at bytes specified in file
+#define MUSIC_SEP_DISC 0x19
+#define MUSIC_XM_DISC 0x1A //like seq_disc, needs a vab_disc loaded
+#define MUSIC_STR_DISC 0x1B //filename on disc is file, for MENU_VFS_RAM. normal MUSIC_STR/XA loads from disc by position
+#define MUSIC_XA_DISC 0x1C //for this and MUSIC_STR_DISC above speed is & 0x1000 and & 0x2000 in basepos
+*/
+
+#define MENU_CANT_SELECT 0x80
+
+#define MENU_VFS_RAMCD 0xEF //the below but laods stuff from CD. add 2 dummy files (basesize) to both to replace with . and ..
+//if cd load isnt needed we can use below. all of it will be loaded into ram from cd.
+#define MENU_VFS_RAM 0xF0 //compiled into exe, EXTENDEDFILEDETAILS[] is in the file instead of VFS directory entry
+#define MENU_PROGRAM_TITLE 0xF1 //replaces "game idiot". is first file of MENU_VFS_RAM.
+//for MENU_PROGRAM_TITLE size is config flags. if 0x1, the title won't be loaded. pos is file to autorun if any
+//basesize is nuber of files total in the VFS, basesize is number of files to skip (move menu pointer)
+#define MENU_VFS_DISC 0xF2 //load vh/vb/seq from original disc and play them, menu data loaded entirely into memory (4 byte aligned)
+#define MENU_TXTPIMP 0xF3
+#define MENU_LASTDIR 0xF4
+#define MENU_TXTPSF 0xF5
+#define MENU_TXTLOSER 0xF6
+#define MENU_XA1X 0xF7
+#define MENU_XA2X 0xF8
+#define MENU_XA 0xF9
+#define MENU_DA 0xFA
+#define MENU_DIR 0xFB
+#define MENU_VFSBYTE 0xFC
+#define MENU_VFSSECTOR 0xFD
+#define MENU_VFS 0xFE
+#define MENU_TXT 0xFF
+
+#define CHANNEL_STEREO 0x00
+#define CHANNEL_MONO 0x01
+#define CHANNEL_LEFT 0x02
+#define CHANNEL_RIGHT 0x03
+#define CHANNEL_REVERSE 0x04
+#define CHANNEL_MONOLEFT 0x05
+#define CHANNEL_MONORIGHT 0x06
+#define CHANNEL_REVERSELEFT 0x07
+#define CHANNEL_REVERSERIGHT 0x08
+
+#define XM_XMNTSC 0x00
+#define XM_S3MNTSC 0x01
+#define XM_XMPAL 0x02
+#define XM_S3MPAL 0x03
+
+#define OSDTYPES 33
+
+#define OSD_NONE 0x00
+#define OSD_VOLUME 0x01
+#define OSD_MVOLUME 0x02
+#define OSD_CHANNELS 0x03
+#define OSD_PANREGION 0x04
+#define OSD_TICKMODE 0x05
+#define OSD_LOOPS 0x06
+#define OSD_BORDERS 0x07
+#define OSD_BITDEPTH 0x08
+#define OSD_REVMODE 0x09
+#define OSD_REVVOL 0x0A
+#define OSD_REVDEPTH 0x0B
+#define OSD_REVDELAY 0x0C
+#define OSD_REVFEEDBACK 0x0D
+#define OSD_SETREVERB 0x0E
+#define OSD_MINUTES 0x0F
+#define OSD_SECONDS 0x10
+#define OSD_FRAMES 0x11
+#define OSD_SETTIME 0x12
+#define OSD_USEREVERB 0x13
+#define OSD_REVERBWAIT 0x14
+#define OSD_REVERBPAUSE 0x15
+#define OSD_REPEATDELAY 0x16
+#define OSD_REPEATSPEED 0x17
+#define OSD_FORCE 0x18
+#define OSD_SEEKMINUTES 0x19
+#define OSD_SEEKSECONDS 0x1A
+#define OSD_SEEKFRAMES 0x1B
+#define OSD_DISPTIME 0x1C
+#define OSD_TEMPO 0x1D
+#define OSD_PAUSE 0x1E
+#define OSD_SJIS 0x1F
+#define OSD_REALLOC 0x20
+
+#define OSD_ALTNONE 0xFF
+
+//extern unsigned long __heapbase;
+//extern unsigned long __heapsize;
+
+void InitSPUHardware(void);
+int PlayXM(void);
+u_char XASpeed(CdlLOC fp, XASECTOR* buf, int sect, u_char file, u_char channel, EXTENDEDFILEDETAILS* menu, int nmax, int flen, int sectmin, u_char buf_full);
+int InitMusic(u_char type);
+int LoadMusic(EXTENDEDFILEDETAILS file, char* LongPath);
+int PlayMusic(EXTENDEDFILEDETAILS file, u_char force_type, char* LongPath);
+int UnloadMusic(u_char type);
+int ExitMusic(u_char type);
+int PXMCount(u_char* ptr);
+u_char* PXMFile(u_char* ptr, int file);
+int PXMSize(u_char* ptr, int file);
+u_char* VBFile(u_char* ptr);
+int ModChannels(u_char* ptr);
+//void InitExe(EXTENDEDFILEDETAILS file, char* LongPath);
+int SeekMusic(u_char type, short absolute, int pos, int min, int max, int seconds, int minutes, u_char speed);
+u_char TypeSpeed(u_char type);
+short SetVolume(short vol, u_char type);
+//void ResetCounters();
+int PlayPauseMusic (u_char type);
+void OSDSelect(u_char type);
+void OSDIncDec(int val, u_char type);
+int constrain(int val, int min, int max);
+short SetChannels(short chan, u_char type);
+int OSDGetVal(u_char type);
+short SetMVolume(short mvol, u_char type);
+char* SplitFilename (char* fname, char* fname2, char* fname0);
+u_long CnfUlong (char* cnf, char* entry, int base);
+int CurrentTime(u_char type);
+short SetTickMode(short mode);
+short SetReverb(short mode, short depth, u_char type);
+short SetReverbDepth(short depth, u_char type);
+short SetReverbVolume(short vol, u_char type);
+short SetReverbDelay(short delay, u_char type);
+short SetReverbFeedback(short feedback, u_char type);
+void SetAllReverbs(u_char type);
+void CdStopMusic(u_char type);
+void LoadParamsV2(ParamsV2* params);
+u_char* XMFile(u_char* ptr, u_long magic);
+short SetTempo(short tempo, u_char type);
+int VHSize(u_char* ptr);
+int VBSize(u_char* ptr, u_long magic, char use_magic);
+void XACallback(int intr, u_char *result);
+//void AddCDDAMenu(void);
\ No newline at end of file
-- 
2.51.1.windows.1

